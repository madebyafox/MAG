---
title: "MAG — Pilot 0 EDA"
author: "ANONYMIZED"
date: "2024-02-04"
output:
  html_document:
    theme: flatly
    code_folding: hide
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    toc_depth: 5
  pdf_document:
    toc: yes
    toc_depth: '4'
always_allow_html: yes
font-family: DejaVu Sans
mainfont: DejaVu Sans
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#UTILITIES
library(Hmisc) # %nin% operator
library(tidyverse) #all the things
library(magrittr) #special pipes like %<>%
library(summarytools) #data quality
library(jtools) #Social Science regression utilities
library(lubridate) #dealing with dates

#VIZ
library(kableExtra) #printing tables
library(ggformula) #regression syntax viz
# library(vcd) #mosaic plots
# library(vcdExtra) #mosaic plot helpers
library(ggstatsplot) #dummies

#MODELLING
library(easystats) #modelling helpers
library(see)
library(sjPlot)
library(lme4)
library(lmerTest) #for CIs in glmer

options(readr.show_col_types = FALSE) #don't show coltypes on read_csv

#POWER ANALYSIS
library(pwrss)

#ARF ONLY — MANUAL RUN
# setwd("~/Code/IXN-Characterizing_Interaction/IXN-D_Characterizing_Interaction/ANALYSIS")

```

Data were exported from TODO to file `tbd` which wasTODO  `TODO` by TODO.


```{r WRANGLING, message=FALSE, warning=FALSE}

#df_raw will always be the unaltered version of imported data
# 1 row per subject 
df_raw <- read_csv("data/CLEAN_v2_testdata.csv", col_names = TRUE)

#### MASTER WIDE FORMAT DATA FRAME ##########################
# 1 row per subject, each trial is a set of columns prefixed by the stimulus number eg. 1_Q..., 10_Q....
#DROP first two rows —— qualtrics specs 
df_data <- df_raw[-c(1:2),] %>%  select(
#DROP junk columns
  -EndDate, -IPAddress,-Progress,-RecordedDate,
  -RecipientLastName, -RecipientFirstName, -RecordedDate, -RecipientEmail,
  -ExternalReference, -LocationLatitude, -LocationLongitude, 
  -UserLanguage, -CONSENT, -ELIGIBILITY, -PROLIFIC_PID,
  -Q_RecaptchaScore, 
  -contains("Q1") #junk end columns
) %>% rename (  #RENAME COLUMNS
  ID_QUALTRICS = ResponseId,
  duration_sec = `Duration (in seconds)`,
  BROWSER_OS = `BROWSER_Operating System`,
  PLATFORM = Q_PLATFORM
) %>% mutate(
  StartDate = mdy_hm(StartDate),
  duration_sec = as.numeric(duration_sec) #weird boolean data should only be for the test generator
)

## TODO HANDLE DEMOGRAPHICS AND PARTICIPANT POOL LOGISTICS 
##temporary adding simulated sample data to approximate pool 
x <- sample(x = c("POP1", "POP2"),
       prob = c(.5, .5), # Make the coin biased for Heads
       size = nrow(df_data),
       replace = TRUE)
df_data$POOL <- x


#SET CERTAIN COLUMNS AS VECTORS
#columns that should be vectors
vecs <- c("ID_QUALTRICS","ID_PROLIFIC","Status",
          "Finished", "DistributionChannel", "PLATFORM", 
          "BROWSER_Browser", "BROWSER_Version", "BROWSER_OS", "BROWSER_Resolution",
          "POOL")


#super duper special pipe that is like an apply?
# https://stackoverflow.com/questions/33180058/coerce-multiple-columns-to-factors-at-once
df_data %<>% mutate_each_(funs(factor(.)),vecs)


#### SUBJECT DATA FRAME ##########################
# 1 row per subject 
#TODO eventually combine with demographic data 
df_subjects <- df_data %>% select(
  ID_QUALTRICS, ID_PROLIFIC, 
  duration_sec, DistributionChannel, 
  StartDate, Status, Finished, PLATFORM, POOL,
  contains("BROWSER")
) 

## CHECK FOR SURVEY COMPLETION
print("Number of subjects who didn't finish survey?")
sum(df_subjects$Finished == FALSE)
#this _should_ always be TRUE because we configured Qualtrics to not save unless the survey is finished 
n_subjects <- nrow(df_subjects)



#TODO FOR REAL DATA NEED TO HANDLE STATUS COLUMN to make sure not test data is in there 


#### RESPONSE DATA FRAME (WIDE) ##########################
# 1 row per subject, only response and relevant participant data 
df_responses <- df_data %>% select(
  ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("_")
)

#### CONSTRUCTING RESPONSES FRAME (LONG) ##########################
#SUPER FLIPPIN HACKY JANKS BC QUALTRICS IS THE WORST ---- COULD refactor this using functions 

#get the data for the first graph
graph_1 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("1_")) %>% 
  mutate(
    graph = "s1",
    in_loop = `1_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^1_","")) #strip the 1_ prefix

#get the data for the second graph
graph_2 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("2_")) %>% 
  mutate(
    graph = "s2",
    in_loop = `2_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^2_","")) #strip the 2_ prefix


#get the data for the third graph
graph_3 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("3_")) %>% 
  mutate(
    graph = "s3",
    in_loop = `3_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^3_","")) #strip the 3_ prefix


#get the data for the fourth graph
graph_4 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("4_")) %>% 
  mutate(
    graph = "s4",
    in_loop = `4_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^4_","")) #strip the 4_ prefix


#get the data for the fifth graph
graph_5 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("5_")) %>% 
  mutate(
    graph = "s5",
    in_loop = `5_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^5_","")) #strip the 5_ prefix


#get the data for the sixth graph
graph_6 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("6_")) %>% 
  mutate(
    graph = "s6",
    in_loop = `6_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^6_","")) #strip the 6_ prefix


#get the data for the seventh graph
graph_7 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("7_")) %>% 
  mutate(
    graph = "s7",
    in_loop = `7_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^7_","")) #strip the 7_ prefix

#get the data for the eigth graph
graph_8 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("8_")) %>% 
  mutate(
    graph = "s8",
    in_loop = `8_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^8_","")) #strip the 8_ prefix

#get the data for the ninth graph
graph_9 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("9_")) %>% 
  mutate(
    graph = "s9",
    in_loop = `9_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^9_","")) #strip the 9_ prefix

#get the data for the tenth graph
graph_10 <- df_responses %>% 
  select(ID_QUALTRICS, PLATFORM, POOL, duration_sec, contains("10_")) %>% 
  mutate(
    graph = "s10",
    in_loop = `10_loop-number`
  ) %>% rename_all(~stringr::str_replace(.,"^10_","")) #strip the 10_ prefix


#nrow(df_responses) should be nrow(df_data) X 10, if each participant saw 10 graphs
df_responses <- bind_rows(graph_1 ,graph_2, graph_3, graph_4, graph_5, 
                       graph_6, graph_7, graph_8, graph_9, graph_10)


#get rid of trailing _1
df_responses <- df_responses %>% 
  rename_all(~stringr::str_replace(.,"_65","")) %>%  #strip the _65 suffix
  rename_all(~stringr::str_replace(.,"_1","")) %>%   #strip the _1 suffix
  select(-`loop-number`, -contains(c("_First Click", "_Last Click"))) %>% 
  rename(
    Q_MAKER_CHAR_LATENCY_sec    =  'Q_MAKER_CHAR_LATENCY_Page Submit',
    Q_MAKER_ATT_LATENCY_sec     =  'Q_MAKER_ATT_LATENCY_Page Submit',
    Q_CONCLUSION_LATENCY_sec    =  'Q_CONCLUSION_LATENCY_Page Submit',
    Q_MAKER_CHAR_LATENCY_clicks =  'Q_MAKER_CHAR_LATENCY_Click Count',
    Q_MAKER_ATT_LATENCY_clicks =  'Q_MAKER_ATT_LATENCY_Click Count',
    Q_CONCLUSION_LATENCY_clicks =  'Q_CONCLUSION_LATENCY_Click Count'
  )

x <- colnames(df_responses) 
#columns that should be vectors
vecs <- c( "Q_ENCOUNTER","comment", "share", "share_comment", "research","unfollow", "NOTHING", 
           "Q_MAKER_ID", "Q_INSTRUMENT_ID", "graph", "in_loop", "POOL")
#columns that should be doubles
nums <- c( "Q_MAKER_ID_CONF", "Q_MAKER_AGE", "Q_MAKER_GENDER", "Q_MAKER_DESIGN", 
           "Q_MAKER_DATA", "Q_MAKER_SPECTRUM", "Q_MAKER_EXPERT", 
          "Q_MAKER_BIAS", "Q_MAKER_ALIGNMENT", "Q_MAKER_COMPETENCE", "Q_MAKER_TRUST",
          "Q_MAKER_POLITE", "Q_MAKER_CARE", "Q_INSTRUMENT_CONF", "Q_CHART_INFORM",
          "Q_CHART_LIKE", "Q_CHART_EFFECTIVE", "Q_CHART_TRUST", "Q_CHART_AESTHETIC", 
          "Q_CONCLUSION_LATENCY_sec", "Q_MAKER_CHAR_LATENCY_sec", "Q_MAKER_ATT_LATENCY_sec", 
          "Q_CONCLUSION_LATENCY_clicks", "Q_MAKER_CHAR_LATENCY_clicks", "Q_MAKER_ATT_LATENCY_clicks")
explains <- c("Q_BEHAVIOR_EXPLAIN", "Q_MAKER_ID_DETAIL",  "Q_MAKER_CHAR_EXPLAIN","Q_MAKER_ATT_EXPLAIN", "Q_INSTRUMENT_DETAIL", "Q_CONCLUSION_EXPLAIN")


#super duper special pipe that is like an apply?
# https://stackoverflow.com/questions/33180058/coerce-multiple-columns-to-factors-at-once
df_responses %<>% mutate_each_(funs(factor(.)),vecs)
df_responses %<>% mutate_each_(funs(as.numeric(.)),nums)


#df just for free response variables 
df_freeresponse <- df_responses %>% select(ID_QUALTRICS, PLATFORM, POOL, Q_BEHAVIOR_EXPLAIN, Q_MAKER_ID,  Q_MAKER_ID_CONF, Q_MAKER_ID_DETAIL, Q_MAKER_CHAR_EXPLAIN, Q_MAKER_ATT_EXPLAIN, Q_INSTRUMENT_ID, Q_INSTRUMENT_CONF, Q_INSTRUMENT_DETAIL, Q_CONCLUSION_EXPLAIN)

#remove free responses from df_graphs and calc time in mins
df_responses <- df_responses %>% select(-one_of(explains)) %>% 
  mutate(duration_min = duration_sec/60)


#REMOVE TEMP DATAFRAMES
rm(graph_1, graph_2, graph_3, graph_4, graph_5, graph_6, graph_7, graph_8, graph_9, graph_10)


#SANITY CHECK 
```

`df_raw` should contain 2 more rows than `df_data` (qualtrics config)
`df_data` and `df_subjects` are one row per participant 
`df_responses` and `df_freeresponse` are one row per participant trial (i.e. participant X t number of trials)

# DATA PROFILE

```{r PROFILER, results="asis" }

df_responses%>% summarytools::dfSummary(
             varnumbers = FALSE,
             plain.ascii  = FALSE,
             graph.magnif = 0.75,
             style        = "grid",
             tmp.img.dir  = "temp",
             missing.col = FALSE, 
             method = "render"
)

```


## TODO Handle Attention Checks
## TODO Handle Behaviour Yes/Nos
## TODO Handle Instrument Multi-select






# EXPLORATORY DATA ANALYSIS

## PLATFORM

```{r engagement}

## PLOT  participant PLATFORM X POOL 
# plot(df_responses$PLATFORM ~ df_responses$POOL)
gf_bar( ~ PLATFORM, fill = ~ POOL, data = df_subjects) + 
  facet_grid( POOL ~ .) + 
  theme_minimal() + 
  ggtitle( label = "Participant PLATFORM choice by POOL")
ggbarstats( data = df_subjects, 
            x = PLATFORM, y = POOL) + 
ggtitle( label = "Participant PLATFORM choice by POOL")



## STATISTICAL POWER
# ncp non-centrality parameter (lambda)
# df degrees of freedom. eg. for the test of homogeneity or independence df = (nrow - 1)*(ncol - 1)



df = (nrow(df_subjects) - 1) * (nlevels(df_subjects$PLATFORM) - 1)
power.chisq.test(ncp = 15, 
                 df = df, 
                 alpha = 0.05,
                 verbose = TRUE,
                 plot = TRUE)

#SEE 
# https://ladal.edu.au/pwr.html#Power_Analysis_for_(chi)2-tests
# w = effect size, cohen's guidelines are 
# small ≥ 0.1, medium ≥ 0.3, and large ≥ 0.5
#N = number of observations 


## DEGREES OF FREEDOM
#The degrees of freedom for the chi-square are calculated using the following #formula: df = (r-1)(c-1) where r is the number of rows and c is the number of #columns. If the observed chi-square test statistic is greater than the critical ##value, the null hypothesis can be rejected.


## CHI SQUARE GOODNESS OF FIT 
## ie. are the 6 platforms chosen in equal probability?
#1—CALCULATE EFFECT SIZE OF GIVEN EFFECT
c = 6   #number of categories of platform
null <- rep(1/c, c) #equal probability across all six categories 

prop_platform <- df_subjects %>% group_by(PLATFORM) %>% summarise(
  n = sum(n)
)



n = nrow(df_subjects) 
pwr.chisq.test(w = 0.4, 
               N = n,
               df = df,
               sig.level=0.05)

```
