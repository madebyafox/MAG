---
title: "VIBES STUDY 2 ANALYSIS — STIMULUS CATEGORY LEVEL"
author: "ANONYMIZED"
date: "2024-08-07"
output:
  html_document:
    theme: flatly
    code_folding: hide
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    toc_depth: 6
  pdf_document:
    toc: yes
    toc_depth: '5'
always_allow_html: yes
font-family: DejaVu Sans
mainfont: DejaVu Sans
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#UTILITIES
library(Hmisc) # %nin% operator
library(psych) #describe()
library(tidyverse) #all the things
library(magrittr) #special pipes like %<>%
library(summarytools) #data quality
library(lubridate) #dealing with dates

#EDA
library(qacBase)

#VIZ
library(kableExtra) #printing tables
library(ggformula) #regression syntax viz
# library(vcd) #mosaic plots
# library(vcdExtra) #mosaic plot helpers
library(ggstatsplot) #dummies
library(gghalves) #half boxplots 
library(GGally) #extends ggplot for EDA 
library(corrplot) #sophisticated correlation plots
library(ggeasy) #easy labelling
library(ggh4x) #guides [dual axes]
library(patchwork) #multi-plot layout
library(ggdist) #raincloud plots and other distributionals
library(ggridges) #ridge plots
library(viridis) #color palettes
library(RColorBrewer) #color palettes
library(plotly) # interactive graphs
library(paletteer) #more palettes
library(lessR) ##very pretty donuts 
library(ggsankey) ## ggplot2 sankey extension
library(interactions) ##easier regression ixn plots.srlsy



#MODELLING
library(jtools) #Social Science regression utilities
library(easystats) #modelling helpers
library(see)
library(sjPlot)
library(lme4)
library(broom.mixed) #tidy mixed models
library(lmerTest) #for CIs in glmer
library(equatiomatic) ## extracting model formula
library(latex2exp) ## extracting and printing model formula

#CONFIG
options(chromote.headless = "new") #for webshot workarounds saving 'screenshots' of rendered figs
options(readr.show_col_types = FALSE) #don't show coltypes on read_csv
n_blocks = 6


## IMPORTANT 
## SET TO TRUE when running file; but FALSE when rendering file (don't need to re-save on render)
GRAPH_SAVE = TRUE #set to true to generate all the SD graphs and save to folders 


```

In VISUALIZATION VIBES project Study 2, participants completed an
*attitutde eliciation* survey, asking questions about their attitude
toward (5) stimulus images (data visualizations). Each participant was
randomly assigned to one of 6 stimulus blocks, each containing 1 image
from each of (4) pseudo-categories (ranging from most abstract to most
figural). Each participant started by responding to questions for a
single 'common' stimulus (that is thus super-powered as it was seen by
all participants). Two participant recruitment pools were used:
Prolific, with a smaller set of participants recruited from Tumblr (to
replicate and compare survey results to Study 1 interviews with
participants sourced from Tumblr).

This notebook contains code to replicate quantitative analysis of data
from Study 2 reported in the CHI submission. Note that due to limited
space, we were unable to report results for *all* stimulus blocks, and
all possible analyses. A separate set of R notebooks are included in the
supplementary materials that document analysis of the other blocks not
reported here.

**This notebook includes analysis and exploration of the data set at the
stimulus category level**

# SETUP

*We start by importing data files previously wrangled in
`0_VIBES_S2_wrangling.Rmd`.*

## Import Data

```{r import-refs, message=FALSE, warning = FALSE}

############## IMPORT REFERENCE FILES
ref_stimuli <- readRDS("data/input/REFERENCE/ref_stimuli.rds")
ref_surveys <- readRDS("data/input/REFERENCE/ref_surveys.rds")
ref_labels <- readRDS("data/input/REFERENCE/ref_labels.rds")
ref_labels_abs <- readRDS("data/input/REFERENCE/ref_labels_abs.rds")

############## SETUP Graph Labels
ref_stim_id <- levels(ref_stimuli$ID)
ref_cat_questions <- c("MAKER_ID","MAKER_AGE","MAKER_GENDER")
ref_free_response <- c("MAKER_DETAIL", "MAKER_EXPLAIN", "TOOL_DETAIL", "CHART_EXPLAIN")
ref_conf_questions <- c("MAKER_CONF", "AGE_CONF", "GENDER_CONF", "TOOL_CONF")
ref_sd_questions <- rownames(ref_labels)
ref_sd_questions_abs <- rownames(ref_labels_abs)
  

# ref_blocks <- c("block1", "block2", "block3", "block4", "block5", "block6")
ref_blocks <- c(1,2,3,4,5,6)

```

```{r import-data, message=FALSE, warning = FALSE}

############## IMPORT DATA FILES
# df_data <- readRDS("data/output/df_data.rds") #1 row per participant — WIDE
df_participants <- readRDS("data/output/df_participants.rds") #1 row per participant — demographic
df_questions <- readRDS("data/output/df_questions.rds") #1 row per question — LONG
df_sd_questions_wide <- readRDS("data/output/df_sd_questions_wide.rds") # only sd questions WIDE


df_tools <- readRDS("data/output/df_tools.rds") #multiselect format for tools Question
df_actions <- readRDS("data/output/df_actions.rds") # multiselect format for action Question
# # df_graphs_full <- readRDS("data/output/df_graphs_full.rds") #includes free response data

df_graphs <- readRDS("data/output/df_graphs.rds") #only categorical and numeric questions
df_sd_questions_long <- readRDS("data/output/df_sd_questions_long.rds") # only sd questions LONG

### DATA FILES WITH (VARIABLE-WISE) Z-SCORED SEMANTIC DIFFERENTIAL QS 
df_graphs_z <- readRDS("data/output/df_graphs_z.rds") #only categorical and numeric questions
df_sd_questions_long_z <- readRDS("data/output/df_sd_questions_long_z.rds") # only sd questions LONG


### DATA FILES WITH ABSOLUTE VALUE SEMANTIC DIFFERENTIAL QS 
df_graphs_abs <- readRDS("data/output/df_graphs_abs.rds") #only categorical and numeric questions
df_sd_questions_long_abs <- readRDS("data/output/df_sd_questions_long_abs.rds") # only sd questions LONG

```

## Set up Graphing

```{r setup-pallettes}

############## SETUP Colour Palettes
#https://www.r-bloggers.com/2022/06/custom-colour-palettes-for-ggplot2/

## list of color pallettes
my_colors = list(
  politics = c("#184aff","#5238bf", "#4f4a52" ,"#84649c", "#ff0000"),
  blackred = c("black","red"),
  greys = c("#707070","#999999","#C2C2C2"),
  greens = c("#ADC69D","#81A06D","#567E39","#2D5D16","#193E0A"),
  smallgreens = c("#ADC69D","#567E39","#193E0A"), ## MALE FEMALE OTHER
  olives = c("#CDCEA1","#B8B979","#A0A054","#78783F","#50502A","#35351C"),
  lightblues = c("#96C5D2","#61A2B2","#3C8093","#2C6378","#1F4A64"),
  darkblues = c("#7AAFE1","#3787D2","#2A73B7","#225E96","#1A4974","#133453"),
  reds = c("#D9B8BD","#CE98A2","#B17380","#954E5F","#78263E","#62151F"),
  traffic = c("#CE98A2","#81A06D","yellow"),
  questions = c("#B17380","#3787D2", "#567E39", "#EE897F"),
  tools= c("#D55662","#EE897F","#F5D0AD","#A0B79B","#499678","#2D363A"), #? ... design.....vis...... programming
  encounter = c("#8E8E8E","#729B7D"), ##SCROLL ENGAGE
  actions2 = c("#8E8E8E","#729B7D"),
  actions4 = c("#8E8E8E", "#A3A3A3","#729B7D","#499678"),
  actions3 = c("#8E8E8E","#99b898ff","#fdcea8ff"),
  actions = c("#8E8E8E","#2A363B","#99b898ff","#fdcea8ff","#ff837bff","#e84a60ff"),
  
  platforms = c("#5D93EA","#FF70CD", "#3BD3F5", "#8B69B5","black"),
  amy_gradient =  c("#ac57aa", "#9e5fa4", "#90689f", "#827099", "#747894", "#66818e", "#578988", "#499183", "#3b997d", "#2da278", "#1faa72"),
  my_favourite_colours = c("#702963", "#637029",    "#296370")
)

## function for using palettes
my_palettes = function(name, n, all_palettes = my_colors, type = c("discrete","continuous"), direction = c("1","-1")) {
  palette = all_palettes[[name]]
  if (missing(n)) {
    n = length(palette)
  }
  type = match.arg(type)
  out = switch(type,
               continuous = grDevices::colorRampPalette(palette)(n),
               discrete = palette[1:n]
  )
  out = switch(direction,
               "1" = out,
               "-1" = palette[n:1])
  structure(out, name = name, class = "palette")
}

```

```{r SD-GRAPHING-FUNCTIONS}


############## RETURNS SD STACKED AND COLORED BY BY X
## LOOP STYLE
multi_sd <- function (data, left, right, x, y, color) {

  # g <- ggplot(df, aes(y = .data[[x]], x = {{y}}, color = {{color}}))+
  g <- ggplot(data, aes(y = .data[[x]], x = .data[[y]], color = .data[[color]]))+
  geom_boxplot(width = 0.5) +
  geom_jitter(width = 0.1, alpha=0.5) +
    
  scale_y_continuous(limits=c(-1,101)) +
  labs(x="", y="") +
  coord_flip() +
  guides(
    y = guide_axis_manual(labels = left),
    y.sec = guide_axis_manual(labels = right)
  ) + theme_minimal()

  return(g)
}


############## RETURNS SINGLE SD 
## LOOP STYLE
single_sd <- function (data, left, right, x) {

  g <- ggplot(data, aes(y = {{x}}, x = ""))+
  geom_boxplot(width = 0.5) +
  geom_jitter(width = 0.1, alpha=0.5) +
  scale_y_continuous(limits=c(-1,101)) +
  labs(x="", y="") +
  coord_flip() +
  guides(
    y = guide_axis_manual(labels = left),
    y.sec = guide_axis_manual(labels = right)
  ) + theme_minimal()

  return(g)
}


# ######## RETURNS SINGLE SD
# ##  APPLY STYLE
plot_sd = function (data, column, type, mean, facet, facet_by, boxplot, labels) {

  ggplot(data, aes(y = .data[[column]], x="")) +
    {if(boxplot) geom_boxplot(width = 0.5) } +
    geom_jitter(width = 0.1, alpha=0.2, {if(facet) aes(color=.data[[facet_by]])}) +
    {if(mean)
      stat_summary(fun="mean", geom="point", shape=20, size=5, color="blue", fill="blue")
      } +
    {if(mean)
      ## assumes data has been passed in with mean column at m
      # stat_summary(fun="mean", geom="text", colour="blue",  fontface = "bold",
      #            vjust=-1.25, hjust = 0.50, aes( label=round(..y.., digits=0)))
      stat_summary(fun="mean", geom="text", colour="blue",  fontface = "bold",
                 vjust=-1.25, hjust = 0.50, aes( label=round(..y.., digits=0)))
      } +

    {if(facet) facet_grid(.data[[facet_by]] ~ .)} +
    # scale_y_continuous(limits=c(-1,101)) +
    labs(x="", y="") +
    coord_flip()  +
    {if(type == "S")
      guides(
        y = guide_axis_manual(labels = labels[column,"left"]),
        y.sec = guide_axis_manual(labels = labels[column,"right"])
      )} +
    {if(type == "Q")
      guides(
        y = guide_axis_manual(labels = labels[q,"left"]),
        y.sec = guide_axis_manual(labels = labels[q,"right"])
      )} +
  theme_minimal()  +
     labs (
       caption = column
     ) + easy_remove_legend()
}

```



# STIMULUS-CATEGORY

For the purpose of optimizing aesthetic diversity of stimuli seen by
each participant, we organized the stimuli into 4 approximate
'categories' of abstraction, where A = the most abstract, and D the most
figural. Each participant first saw the common stimulus (B0-0) followed
by one stimulus from each category (order randomized) in a block
structure.

## SAMPLE

### Sample Demographics

```{r sample-size}

df <- df_participants

## FOR DESCRIPTIVES PARAGRAPH
# #PROLIFIC
df.p <- df %>% filter(Distribution == "PROLIFIC")
desc.gender.p <- table(df.p$D_gender) %>% prop.table()
names(desc.gender.p) <- levels(df.p$D_gender)
p_participants <- nrow(df.p)

# #TUMBLR
df.t <- df %>% filter(Distribution == "TUMBLR")
desc.gender.t <- table(df.t$D_gender) %>% prop.table()
names(desc.gender.t) <- levels(df.t$D_gender)
t_participants <- nrow(df.t)


```

For study 2, a total of `r p_participants + t_participants` participants
were recruited from US-located English speaking users of TUMBLR (n =
`r t_participants`) and PROLIFIC (n = `r p_participants`).

`r p_participants` individuals from PROLIFIC participated in Study 2, (
`r round(desc.gender.p[["Female"]],2)*100`% Female,
`r round(desc.gender.p[["Male"]],2)*100`% Male,
`r round(desc.gender.p[["Non-binary / third gender"]],2)*100`%
Non-binary,
`r (round((desc.gender.p[["Prefer not to say"]] + desc.gender.p[["Prefer to self-describe"]]),2)) * 100`%
Other).

`r t_participants` individuals from Tumblr participated in Study 2, (
`r round(desc.gender.t[["Female"]],2)*100`% Female,
`r round(desc.gender.t[["Male"]],2)*100`% Male,
`r round(desc.gender.t[["Non-binary / third gender"]],2)*100`%
Non-binary,
`r (round((desc.gender.t[["Prefer not to say"]] + desc.gender.t[["Prefer to self-describe"]]),2)) * 100`%
Other). Note that a higher proportion of participants recruited from
TUMBLR report identities other than cis-gender Female and cis-gender
Male.

### Study Response Time

```{r demo-response-time}

df <- df_participants

## for descriptives paragraph
p.desc.duration <- psych::describe(df %>% filter(Distribution=="PROLIFIC") %>% pull(duration.min))
t.desc.duration <- psych::describe(df %>% filter(Distribution=="TUMBLR") %>% pull(duration.min))

```

PROLIFIC SAMPLE (n = `r p.desc.duration$n` ) participant response times
ranged from `r p.desc.duration$min` to `r p.desc.duration$max` minutes,
with a mean response time of `r round(p.desc.duration$mean,2)` minutes,
SD = `r (round(p.desc.duration$sd,2))`.

TUMBLR SAMPLE (n = `r t.desc.duration$n` ) participant response times
ranged from `r t.desc.duration$min` to `r t.desc.duration$max` minutes,
with a mean response time of `r round(t.desc.duration$mean,2)` minutes,
SD = `r (round(t.desc.duration$sd,2))`.

```{r demo-cleanup}
rm(df, df.p, df.t, p.desc.duration, t.desc.duration, desc.gender.p, desc.gender.t, p_participants, t_participants)
```

```{r setup-categories}

#full data except for common stimulus B0-0
df_cat <- df_graphs %>% 
  filter(STIMULUS != "B0-0") %>% 
  mutate(
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY),
    STUDY = "" #dummy variable for univariate visualizations
  )
# %>%
#   mutate(MAKER_ID = fct_rev(MAKER_ID))

```

## CONFIDENCE

When asking participants to identify the type, age and gender of the
maker of a visualization, we also asked participants to indicate their
confidence in these choices.

**Across all participants and all stimuli, are these (categorical)
questions answered with the same degree of confidence?**

Here we examine both the central tendency (mean) and shape of the
distribution for each confidence variable.

```{r compare-confidence}

df <- df_cat %>% select(PID, Distribution, STIMULUS_CATEGORY, STIMULUS,MAKER_CONF, AGE_CONF, GENDER_CONF, TOOL_CONF) %>% 
  pivot_longer(
    cols = c(MAKER_CONF, AGE_CONF, GENDER_CONF, TOOL_CONF),
    names_to = "QUESTION",
    values_to = "CONFIDENCE"
  ) %>% 
  mutate(
    QUESTION = factor(QUESTION, levels=c("MAKER_CONF","AGE_CONF","GENDER_CONF","TOOL_CONF"  ) )
  ) %>% 
  group_by(QUESTION, STIMULUS_CATEGORY) %>% 
  mutate(
    m=round(mean(CONFIDENCE),0) #calc mean for showing in plots 
  )


## B
## CONFIDENCE ACROSS QUESTIONS (all stimuli, all Pps)
## BOXPLOT W/ JITTER
B <-
  df %>% 
  ggplot(aes(x=STIMULUS_CATEGORY, y= CONFIDENCE, fill = STIMULUS_CATEGORY)) + 
  geom_jitter(aes(color = STIMULUS_CATEGORY), alpha = 0.25, position=position_dodge2(width = 0.25)) + 
  geom_boxplot(width = 0.5) + 
  facet_wrap(~QUESTION)+
  ## MEAN
    stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size=3,
                 vjust=+0.5, hjust = -1.5, aes( label=round(m, digits=0)))+
    stat_summary(fun=mean, geom="point", size=2, color="blue", fill="blue") +
  theme_minimal() + easy_remove_legend()
  labs(title = "Confidence by Question and Stimulus Category", caption = "(mean in blue)")


## R
## CONFIDENCE ACROSS QUESTIONS (all stimuli, all Pps)
## RIDGEPLOT W/ INTERVAL MEAN
R <-
  df %>% 
  ggplot(aes(x=CONFIDENCE, y=STIMULUS_CATEGORY, fill=STIMULUS_CATEGORY)) + 
    geom_density_ridges(scale = 0.65, alpha = 0.75, quantile_lines = TRUE) +
    scale_x_continuous(limits = c(0,100))+
    # scale_fill_manual(values = my_palettes(name="questions", direction = "-1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
    stat_pointinterval(side = "bottom", scale = 0.7, slab_linewidth = NA, point_interval = "mean_qi") +
    facet_wrap(~QUESTION)+
  ## MEAN
    stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size=3,
                vjust=+2.5, hjust = 0.50, aes( label=round(m, digits=0)))+
    stat_summary(fun=mean, geom="point", size=2, color="blue", fill="blue") +
  theme_minimal() + 
  labs(title = "Confidence by Question and Stimulus Category", y = "QUESTION", caption =" (mean in blue)") + 
  easy_remove_legend()

B
R
```


## MAKER ID

Participants were asked:

**Who do you think is most likely responsible for having this image
created?\
***options:* (select one). The response is stored as `MAKER_ID`

-   business or corporation

-   journalist or news outlet

-   educational or academic institution

-   government or political organization

-   other organization

-   an individual]\

Participants were also asked: **Please rate your confidence in this
choice.** The response is stored as `MAKER_CONF` .

```{r maker-id-confidence-full}

#FILTER DATASET
df <- df_cat


## D
## MAKER IDENTIFICATION AGGREGATED (all)
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( MAKER_ID = fct_rev(MAKER_ID) )
S <-   ggbarstats( data = dx, x = MAKER_ID, y = STIMULUS_CATEGORY,
                   results.subtitle = FALSE,
                   legend.title = "MAKER ID") + 
    scale_fill_manual(values = my_palettes(name="reds", direction = "1")) +
    theme_minimal() +
    labs( title = "",  x = "", y="") + 
    theme(aspect.ratio = 1)
##############################


## H
## HALF EYE SLAB GGDIST
##############################
H <-
  df %>% 
  group_by(MAKER_ID, STIMULUS_CATEGORY) %>% 
  mutate(count = n(), m = mean(MAKER_CONF)) %>% 
  ggplot(aes(y = MAKER_CONF, x = fct_rev(MAKER_ID), fill = fct_rev(MAKER_ID))) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  facet_wrap(~STIMULUS_CATEGORY)+
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="reds", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="Maker ID Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################
  

S + plot_annotation(
  title = "Maker ID by STIMULUS CATEGORY",
  # subtitle = "the categories of MAKER ID were chosen in similar proportion, 
  # and both the mean (in blue) and shape of distribution of confidence scores is similar across values of Maker ID",
  caption = "(blue indicates mean)"
)

H + plot_annotation(
  title = "Maker ID Confidence by STIMULUS CATEGORY",
  # subtitle = "the categories of MAKER ID were chosen in similar proportion, 
  # and both the mean (in blue) and shape of distribution of confidence scores is similar across values of Maker ID",
  caption = "(blue indicates mean)"
)


```



## MAKER AGE

Participants were asked: **Take a moment to imagine the person(s)
responsible for creating the image. What generation are they most likely
from?\
***options: (select one)* The response was saved as `MAKER_AGE`

-   *boomers (60+ years old)*

-   *Generation X (44-59 years old)*

-   *Millennials (28-43 years old)*

-   *Generation Z (12 - 27 years old]*

Participants were asked: **Please rate your confidence in this choice.**
The response is stored as `AGE_CONF` .

```{r maker-age-confidence-full}

#FILTER DATASET
df <- df_cat


## D
## MAKER IDENTIFICATION AGGREGATED (all)
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( MAKER_AGE = fct_rev(MAKER_AGE) )
S <-   ggbarstats( data = dx, x = MAKER_AGE, y = STIMULUS_CATEGORY,
                   legend.title = "MAKER AGE",
                   results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="lightblues", direction = "1")) +
    theme_minimal() +
    labs( title = "",  x = "", y="") + 
    theme(aspect.ratio = 1)
##############################


  
## H
## HALF EYE SLAB GGDIST
##############################
H <- df %>% 
  group_by(MAKER_AGE, STIMULUS_CATEGORY) %>% 
  mutate(count = n(), m = mean(AGE_CONF)) %>% 
  ggplot(aes(y = AGE_CONF, x = fct_rev(MAKER_AGE), fill = fct_rev(MAKER_AGE))) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  facet_wrap(~STIMULUS_CATEGORY)+
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(..y.., digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="lightblues", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="Maker AGE Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################


S  + plot_annotation(
  title = "Maker AGE by STIMULUS CATEGORY",
  # subtitle = "The value
  # distribution of confidence scores is similar across values of Maker AGE",
  caption = "(blue indicates mean)"
)


H + plot_annotation(
  title = "Maker AGE Confidence by STIMULUS CATEGORY",
  # subtitle = "The value
  # distribution of confidence scores is similar across values of Maker AGE",
  caption = "(blue indicates mean)"
)


```


## MAKER GENDER

Participants were asked: **Take a moment to imagine the person(s)
responsible for creating the image. What gender do they most likely
identify with?\
***options: [female / male / other ] (select one).* Responses were
stored as `MAKER_GENDER.`

Participants were asked: **Please rate your confidence in this choice.**
The response is stored as `GENDER_CONF` .

```{r maker-gender-confidence-full}

#FILTER DATASET
df <- df_cat


## D
## MAKER IDENTIFICATION AGGREGATED (all)
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( MAKER_AGE = fct_rev(MAKER_AGE) )
S <-   ggbarstats( data = dx, x = MAKER_GENDER, y = STIMULUS_CATEGORY,
                   legend.title = "MAKER GENDER", 
                   results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="smallgreens", direction = "1")) +
    theme_minimal() +
    labs( title = "",  x = "", y="") + 
    theme(aspect.ratio = 1)
##############################



## H
## HALF EYE SLAB GGDIST
##############################
H <- df %>% 
  group_by(MAKER_GENDER, STIMULUS_CATEGORY) %>% 
  mutate(count = n(), m = mean(GENDER_CONF)) %>% 
  ggplot(aes(y = GENDER_CONF, x = MAKER_GENDER, fill = MAKER_GENDER)) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  facet_wrap(~STIMULUS_CATEGORY) + 
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(..y.., digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="greens", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="Maker GENDER Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################

  

S + plot_annotation(
  title = "Maker GENDER by STIMULUS CATEGORY",
  # subtitle = "The value
  # distribution of confidence scores is similar across values of Maker AGE",
  caption = "(blue indicates mean)"
)


H + plot_annotation(
  title = "Maker GENDER Confidence by STIMULUS_CATEGORY",
  # subtitle = "The value
  # distribution of confidence scores is similar across values of Maker AGE",
  caption = "(blue indicates mean)"
)

```



## TOOL ID

Participants were asked: **What tools do you think were most likely used
to create this image?\
***options: (select all that apply).* The response was saved as variable
`TOOL_ID` (multi-select)

-   basic graphic design software (e.g. Canva, or similar)

-   advanced graphic design software (e.g. Adobe Illustrator, Figma, or
    similar)

-   data visualization software (e.g. Tableau, PowerBI, or similar)

-   general purpose software (e.g. MS Word/Excel, Google Sheets, or
    similar)

-   programming language (e.g. R, python, javascript, or similar)

Participants were asked: **Please rate your confidence in this choice.**
The response is stored as `TOOL_CONF` .

```{r maker-tool-confidence-full}

#FILTER DATASET
df <- df_tools %>% 
  mutate(
    STUDY = "",
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY)
  )


## D
## MAKER IDENTIFICATION AGGREGATED (all)
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
S <-   ggbarstats( data = df, x = TOOL_ID, y = STIMULUS_CATEGORY,
                   legend.title = "TOOL ID", results.subtitle = FALSE) + 
    scale_fill_paletteer_d("awtools::a_palette", direction = 1)+
    theme_minimal() +
    labs( title = "",  x = "", y="") + 
    theme(aspect.ratio = 1)
##############################



## H
## HALF EYE SLAB GGDIST
##############################
H <-  df %>% 
  group_by(TOOL_ID, STIMULUS_CATEGORY) %>% 
  mutate(count = n(), m = mean(TOOL_CONF)) %>% 
  ggplot(aes(y = TOOL_CONF, x = TOOL_ID, fill = TOOL_ID)) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  facet_wrap(~STIMULUS_CATEGORY) + 
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(..y.., digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="tools", direction = "1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="TOOL ID Confidence", x="", caption="(mean in blue) (median in red)") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################
  

S + plot_annotation(
  title = "TOOL ID by STIMULUS CATEGORY",
  # subtitle = "The value
  # distribution of confidence scores is similar across values of Maker AGE",
  caption = "(blue indicates mean)"
)

H + plot_annotation(
  title = "TOOL ID Confidence by STIMULUS CATEGORY",
  # subtitle = "The value
  # distribution of confidence scores is similar across values of Maker AGE",
  caption = "(blue indicates mean)"
)

```


## ENCOUNTER CHOICE

The first question each participant saw in each stimulus block was: **As
you're scrolling through your feed, you see this image. What would you
do?**

options: keep scrolling, pause and look at the image. (select one) The
response was saved as variable `ENCOUNTER`

```{r}
## B
## ENCOUNTER  BY STIMULUS
## GGSTATSPLOT
df_cat %>% 
  ggbarstats(  
            x = ENCOUNTER, y = STIMULUS_CATEGORY,
            legend.title = "ENCOUNTER",
            results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="encounter", direction = "-1"))+
    theme_minimal() + 
    labs( title = "ENCOUNTER Choice by STIMULUS_CATEGORY", subtitle = "", x = "")
```



### AD HOC EXPLORE ENCOUNTER
```{r}



df_cat %>% 
ggbivariate(outcome = "ENCOUNTER", explanatory = ref_conf_questions)

df_cat %>% 
ggbivariate(outcome = "ENCOUNTER", explanatory = ref_cat_questions)

df_cat %>% 
ggbivariate(outcome = "ENCOUNTER", explanatory = ref_sd_questions)


```



## ACTION CHOICE

The last question participants were asked in each stimulus block was:
**Imagine you encounter the following image while scrolling. Which of
the following are you most likely to do?**

options: (select all that apply). The response was saved as variable
`CHART_ACTION`

-   post a comment

-   share/repost

-   share/repost WITH comment

-   look up more information about the topic or source

-   unfollow/block the source

-   NOTHING—just keep scrolling

```{r}
## B
## ACTION  BY STIMULUS
## GGSTATSPLOT
df_actions %>% mutate(
  CHART_ACTION = fct_rev(CHART_ACTION),
  STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY),
  STUDY="") %>% 
  ggbarstats( x = CHART_ACTION, y = STIMULUS_CATEGORY,
            legend.title = "CHART ACTION",
            results.subtitle = FALSE) + 
    # scale_fill_paletteer_d("awtools::a_palette", direction = 1)+
    scale_fill_manual(values = my_palettes(name="actions", direction = "1"))+
    theme_minimal() + 
    labs( title = "ACTION Choice by CATEGORY ", subtitle = "", x = "")
    

## B
## ACTION  BY STIMULUS
## GGSTATSPLOT
df_actions %>% mutate(
  CHART_ACTION4 = fct_rev(CHART_ACTION4),
  STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY),
  STUDY="") %>% 
  ggbarstats( x = CHART_ACTION4, y = STIMULUS_CATEGORY,
            legend.title = "collapsed CHART ACTION",
            results.subtitle = FALSE) + 
    # scale_fill_paletteer_d("awtools::a_palette", direction = 1)+
    scale_fill_manual(values = my_palettes(name="actions", direction = "1"))+
    theme_minimal() + 
    labs( title = "collapsed ACTION Choice4 by CATEGORY ", subtitle = "", x = "")
    

## B
## ACTION  BY STIMULUS
## GGSTATSPLOT
df_actions %>% mutate(
  CHART_ACTION3 = fct_rev(CHART_ACTION3),
  STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY),
  STUDY="") %>% 
  ggbarstats( x = CHART_ACTION3, y = STIMULUS_CATEGORY,
            legend.title = "collapsed CHART ACTION",
            results.subtitle = FALSE) + 
    # scale_fill_paletteer_d("awtools::a_palette", direction = 1)+
    scale_fill_manual(values = my_palettes(name="actions", direction = "1"))+
    theme_minimal() + 
    labs( title = "collapsed ACTION Choice3 by CATEGORY ", subtitle = "", x = "")
    

## B
## ACTION  BY STIMULUS
## GGSTATSPLOT
df_actions %>% mutate(
  CHART_ACTION2 = fct_rev(CHART_ACTION2),
  STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY),
  STUDY="") %>% 
  ggbarstats( x = CHART_ACTION2, y = STIMULUS_CATEGORY,
            legend.title = "collapsed CHART ACTION",
            results.subtitle = FALSE) + 
    # scale_fill_paletteer_d("awtools::a_palette", direction = 1)+
    scale_fill_manual(values = my_palettes(name="actions", direction = "1"))+
    theme_minimal() + 
    labs( title = "collapsed ACTION Choice2 by CATEGORY ", subtitle = "", x = "")
    
```


## SEMANTIC DIFFERENTIALS

Participants were also asked to rate certain characteristics of the
chart, or its maker, along a **semantic differential scale**,
implemented in Qualtrics as a continuous slider ranging from 0 -\> 100
with biploar adjectives at the end of each scale. The slider defaulted
to the center point (50), and the interface displayed the numeric value
of the slider position as a tooltip while the element had focus. Note
that on both touch and mouse devices participants could interact with
the survey element as a slider (i.e. click and and drag, or touch and
drag) *or* as a visual analogue scale (i.e. click or tap on position
along the scale).

### Full Scales

*The SD scores visualized here are in the same form as the participants'
response scale (slider from 0-100).*


```{r sd-densities-category}
  
#### GROUPED DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, QUESTION, STIMULUS_CATEGORY, value)  
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions),
          STIMULUS_CATEGORY = factor(STIMULUS_CATEGORY, levels = c("A","B","C","D","F")))%>% 
    group_by(QUESTION) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(  c <-ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill=STIMULUS_CATEGORY))+ 
    geom_density_ridges(scale = 0.75, alpha = 0.5, panel_scaling = TRUE) +
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=-0.5, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=1) +
    facet_grid2(.~STIMULUS_CATEGORY)+
    # geom_density_ridges(scale = 1, quantile_lines = TRUE, alpha = 0.25) 
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs(title = "by STIMULUS CATEGORY", y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 40, y= ref_sd_questions, size = 6, vjust=2) + ##raw
    # # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend()
)
  
if(GRAPH_SAVE){
    ggsave(plot = c, path="figs/level_category/distributions", filename =paste0("combined_by_category","_ridges.png"), units = c("in"), width = 10, height = 14  )
}  


```

```{r plot-sd-cleanup}
rm(df,d, c)
```

### Absolute Values

*Here the scale of the semantic differential questions have been
collapsed, such that 0 is the midpoint of the scale (indicating
uncertainty, or not strongly indicating either of the labelled traits)
and both 100 and 0 are 50 (indicating a strong signal toward either of
the labelled traits).*


```{r plot_grouped_ridges_abs}
  #### GROUPED DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long_abs %>% select(1:8, QUESTION, STIMULUS_CATEGORY, value)  
  d <- left_join( x = df, y = ref_labels_abs, 
                  by = c("QUESTION" = "ref_sd_questions_abs")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions),
          STIMULUS_CATEGORY = factor(STIMULUS_CATEGORY, levels = c("A","B","C","D","F")))%>% 
    group_by(QUESTION) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(  c <-ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill=STIMULUS_CATEGORY))+ 
    geom_density_ridges(scale = 0.75, alpha = 0.5, panel_scaling = TRUE) +
    facet_grid2(.~STIMULUS_CATEGORY)+
     ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=-0.5, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=1) +
    # geom_density_ridges(scale = 1, quantile_lines = TRUE, alpha = 0.25) 
    guides(
      y = guide_axis_manual(labels = rev(ref_labels_abs$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels_abs$right))
    ) +
    labs(title = "by STIMULUS CATEGORY (absolute value)", y = "") +
    cowplot::draw_text(text = ref_sd_questions_abs, x = 20, y= ref_sd_questions_abs, size = 6, vjust=2) + ##raw
    theme_minimal() + easy_remove_legend()
)

if(GRAPH_SAVE == TRUE){
    ggplot2::ggsave(plot = c, path="figs/level_category/distributions", filename =paste0("ABS_combined_by_category","_ridges.png"), units = c("in"), width = 10, height = 14  )
}

```

```{r plot-sd-abs-cleanup}
rm(df, d, c)
```

## CORRELATIONS

### correlation matrices — semantic differential

```{r, correlation-matrices}


df <- df_graphs %>% 
  filter(STIMULUS != "B0-0") %>% 
  select(
          MAKER_DESIGN, MAKER_DATA, 
          MAKER_POLITIC, MAKER_ARGUE,
          MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
          CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
          PID)

print("FULL CORRELATION NO RANDOM EFFECT")
## CALCULATE full correlations with no random effects
c <- df %>%  correlation(partial=FALSE, include_factors=FALSE)
(s <- c %>% summary(redundant = FALSE))
plot(s, show_data="point") + labs(title = "Correlation Matrix",
               subtitle="(full correlation; pearson method; Holm p-value adjustment)") + theme_minimal()



print("PARTIAL CORRELATION WITH PID AS RANDOM EFFECT")
#CALCULATE partial correlations with PID as random effect
## (this isolates correlation pairwise factoring out other variables)
c <- df %>% correlation(partial=TRUE,multilevel = TRUE)
(s <- c %>% summary(redundant = FALSE ))


###### VIS WITH CORRELATION PACKAGE
#SEE [correlation] PLOT
g <- plot(s, show_data = "point",   show_text = "label",
     stars=TRUE, show_legend=FALSE,
     show_statistic = FALSE, show_ci = FALSE) + 
     theme_minimal()+
     labs(title = "Correlation Matrix — SD Questions", 
          subtitle="(partial correlation; pearson method; Holm p-value adjustment; participant as random effect)")
     # text = list(fontface = "italic")
g
ggsave(g, scale =1, filename = "figs/level_category/heatmaps/blocks_partial_correlation_no_b00.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)

#PLOT GAUSSIAN GRAPH MODEL
# plot(c)


###### VIS WITH CORRPLOT <- -- customizable but can't save to file ARGH

## GET THE MATRIX
m <- as.matrix(c)


## JUST CIRCLES
corrplot(m, method = 'circle', type = 'lower',
         order = 'original', diag = FALSE, addCoef.col = "#7A7A7A",
         tl.col = "black")






```

These plots depict the PARTIAL CORRELATION pairwise between variables
(partial correlation factors out influence of other variables), with
participant ID as a random effect. The resulting values are pearson
moment-correlation coefficients ranging of -1 (direct negative) to +1
direct positive correlation. These correlations are calculated on the
full scale semantic differential questions (i.e. with the 0 - 100 range,
where 1 and 100 are end points and 50 is the central point)

### correlation matrices — semantic differential — absolute values

```{r, correlation-matrices—abs}


df <- df_graphs_abs %>% 
  filter(STIMULUS != "B0-0") %>% 
  select(
          MAKER_DESIGN, MAKER_DATA, 
          MAKER_POLITIC, MAKER_ARGUE,
          MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
          CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
          PID)

print("FULL CORRELATION NO RANDOM EFFECT")
## CALCULATE full correlations with no random effects
c <- df %>%  correlation(partial=FALSE, include_factors=FALSE)
(s <- c %>% summary(redundant = FALSE))
plot(s, show_data="point") + labs(title = "Correlation Matrix",
               subtitle="(full correlation; pearson method; Holm p-value adjustment)") + theme_minimal()


print("PARTIAL CORRELATION WITH PID AS RANDOM EFFECT")
#CALCULATE partial correlations with PID as random effect
## (this isolates correlation pairwise factoring out other variables)
c <- df %>% correlation(partial=TRUE, multilevel = TRUE)
(s <- c %>% summary(redundant = FALSE ))


###### VIS WITH CORRELATION PACKAGE
#SEE [correlation] PLOT
g <- plot(s, show_data = "point",   show_text = "label",
     stars=TRUE, show_legend=FALSE,
     show_statistic = FALSE, show_ci = FALSE) + 
     theme_minimal()+
     labs(title = "Correlation Matrix — SD Questions — absolute values", 
          subtitle="(partial correlation; pearson method; Holm p-value adjustment; participant as random effect)")
     # text = list(fontface = "italic")
g
ggsave(g, scale =1, filename = "figs/level_category/heatmaps/blocks_partial_correlation_abs_no_b00.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)

#PLOT GAUSSIAN GRAPH MODEL
# plot(c)


###### VIS WITH CORRPLOT <- -- customizable but can't save to file ARGH

## GET THE MATRIX
m <- as.matrix(c)


## JUST CIRCLES
corrplot(m, method = 'circle', type = 'lower',
         order = 'original', diag = FALSE, addCoef.col = "#7A7A7A",
         tl.col = "black")

```


# EXPLORATORY QUESTIONS

### CHART ACTION ~ CATEGORY
#### visualize


```{r}
df <- df_actions %>% 
  select(STIMULUS, STIMULUS_CATEGORY, BLOCK, CHART_ACTION, CHART_LIKE, PID) %>% 
  mutate(
CHART_ACTION = fct_rev(CHART_ACTION),
STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY),
  ) %>% filter(STIMULUS != "B0-0")


# m <- glm(df)


## CATEGORY
## GGSTATSPLOT
##############################
ggbarstats( data = df, x = CHART_ACTION, y = STIMULUS_CATEGORY,
        results.subtitle = FALSE) + 
scale_fill_manual(values = my_palettes(name="actions", direction = "1")) +
theme_minimal() +
# labs( title = "",  x = "", y="") + 
theme(aspect.ratio = 1)
##############################

## BLOCK
## GGSTATSPLOT
##############################
ggbarstats( data = df, x = CHART_ACTION, y = BLOCK,
        results.subtitle = FALSE) + 
scale_fill_manual(values = my_palettes(name="actions", direction = "1")) +
theme_minimal() +
# labs( title = "",  x = "", y="") + 
theme(aspect.ratio = 1)
##############################


## CATEGORY / BLOCK
# GGSTATSPLOT
##############################
grouped_ggbarstats( data = df, x = CHART_ACTION, y = STIMULUS_CATEGORY,   grouping.var=BLOCK,
                results.subtitle = FALSE,
                ggplot.component = scale_fill_manual(values = my_palettes(name="actions", direction = "1"))) + 
theme_minimal() +
# labs( title = "",  x = "", y="") + 
theme(aspect.ratio = 1)
##############################


# BLOCK / CATEGORY
# GGSTATSPLOT
##############################
grouped_ggbarstats( data = df, x = CHART_ACTION, y = BLOCK,   grouping.var=STIMULUS_CATEGORY,
                results.subtitle = FALSE,
                ggplot.component = scale_fill_manual(values = my_palettes(name="actions", direction = "1"))) + 
theme_minimal() +
# labs( title = "",  x = "", y="") + 
theme(aspect.ratio = 1)
##############################

# STIMULUS
# GGSTATSPLOT
# TODO STACKED BAR BY ACTION








```

    
    





#### model 


##### DATA SETUP
```{r }

df <- df_actions %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  filter(STIMULUS != "B0-0") %>%
  select(CHART_ACTION, CHART_ACTION2, CHART_ACTION3, CHART_ACTION4, STIMULUS, STIMULUS_CATEGORY, BLOCK, MAKER_ID, CHART_LIKE, CHART_TRUST, CHART_BEAUTY, MAKER_DESIGN, MAKER_ALIGN, CHART_INTENT, MAKER_TRUST, MAKER_DATA, MAKER_DESIGN, MAKER_ARGUE, MAKER_POLITIC, MAKER_SELF, PID) %>% 
  mutate(
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY), #REVERSE FACTOR ORDER SO A IS REFERENCE
    ALIGN_Z = datawizard::standardise(MAKER_ALIGN),
    TRUST_Z = datawizard::standardise(CHART_TRUST),
    BEAUTY_Z = datawizard::standardise(CHART_BEAUTY),
    LIKE_Z = datawizard::standardise(CHART_LIKE),
    INTENT_Z = datawizard::standardise(CHART_INTENT),
    MAKERTRUST_Z = datawizard::standardise(MAKER_TRUST),
    DESIGN_Z = datawizard::standardise(MAKER_DESIGN),
    DATA_Z = datawizard::standardise(MAKER_DATA),
    ARGUE_Z = datawizard::standardise(MAKER_ARGUE),
    SELF_Z = datawizard::standardise(MAKER_SELF),
    ABS_POLITIC = datawizard::standardize(abs(MAKER_POLITIC - 50)) #standardize after halfving scale 
  ) %>% 
  droplevels()
    
  
    ## (only used if NOT filtering out B0-0)
    ## RECODE #recode b00 graph as category D [bc it fits in that category]
    # STIMULUS_CATEGORY = fct_recode(STIMULUS_CATEGORY, D="F") 
  

```


##### (WIP) CHART ACTION ~ ?

```{r}

## reference level is nothing, 

################## ENCOUNTER ~ CATEGORY + LIKE #################
f <-  "ACTION ~ ?? (1|PID)"
mm <- glmer(CHART_ACTION2 ~ STIMULUS_CATEGORY + LIKE_Z + ABS_POLITIC + (1|PID), 
                data = df,family = "binomial", 
                 control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               optCtrl=list(maxfun=2e5)))
car::Anova(mm, type = 2)
summary(mm)
performance(mm)

m <- mm
f <- f
## REPORT 
# report(m)

## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()


## PLOT PRED
plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "LIKE_Z", "ABS_POLITIC")) + 
  labs(subtitle = f) + theme_minimal()

plot_model(m, type = "pred", terms = c("LIKE_Z", "ABS_POLITIC", "STIMULUS_CATEGORY")) + 
  labs(subtitle = f) + theme_minimal()

plot_model(m, type = "pred", terms = c("ABS_POLITIC", "STIMULUS_CATEGORY","LIKE_Z")) + 
  labs(subtitle = f) + theme_minimal()
## IN PAPER
tab_model(m)
```
CATEGORY, LIKE, POLITICS ABS


```{r}
################## BUILD MODELS #################

# # RANDOM INTERCEPT SUBJECT
# mm.rP <- glmer(ENCOUNTER ~ (1|PID), data = df,family = "binomial")


# # SUBJECT INTERCEPT | FIXED BLOCK 
# ## should be non predictive
# print("ENCOUNTER ~ BLOCK + (1|PID)")
# mm.BrP <- glmer(ENCOUNTER ~ BLOCK + (1|PID), 
#                 data = df,family = "binomial")
# # :: TEST fixed factor 
# compare_performance(mm.rP, mm.BrP, rank = TRUE)
# paste("AIC with fixed effect is lower than random intercept only model?", AIC(logLik(mm.rP)) > AIC(logLik(mm.BrP)) )
# test_lrt(mm.rP,mm.BrP) #same as anova(m0, m1, test = "Chi")
# paste("Likelihood Ratio test is significant? p = ",(test_lrt(mm.rP,mm.BrP))$p[2])
# print("A model with BLOCK is NOT a better fit than (random effect) participant alone")
# car::Anova(mm.BrP, type=2)
# print("BLOCK is NOT significant predictor in the model")
# print("[this is as expected. suggests that we were successful in randomizing stimuli across the blocks]")
```





### ENCOUNTER ~ CATEGORY

Are more figural (e.g. figures with more embellishments) graphs _more likely to be interacted with_ than less figural graphs? 
To address this question, we explore the relationship between `STIMULUS_CATEGORY` and `ENCOUNTER` (whether they would likely scroll past and stop and look at the graph).  

#### visualize 
```{r hypo-category-encounter-vis}

df <- df_graphs %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  filter(STIMULUS != "B0-0") %>% 
  select(STIMULUS, STIMULUS_CATEGORY, BLOCK, ENCOUNTER, CHART_LIKE, CHART_TRUST, PID) %>% 
  mutate(
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY), #REVERSE FACTOR ORDER SO A IS REFERENCE
    ENCOUNTER = fct_rev(ENCOUNTER) #REVERSE SO SCROLL IS REFERENCE
    ## (only used if not filtering out B0-0)
    ## RECODE #recode b00 graph as category D [bc it fits in that category]
    # STIMULUS_CATEGORY = fct_recode(STIMULUS_CATEGORY, D="F") 
  ) %>% droplevels()

## CATEGORY
## GGSTATSPLOT
##############################
ggbarstats( data = df, x = ENCOUNTER, y = STIMULUS_CATEGORY,
            results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="encounter", direction = "1")) +
    theme_minimal() +
    labs( title = "ENCOUNTER by CATEGORY",  x = "", y="",
          subtitle = "the more figural categories (C,D) have a higher proportion of engagement") +
    theme(aspect.ratio = 1)
##############################

## BLOCK
## GGSTATSPLOT
##############################
ggbarstats( data = df, x = ENCOUNTER, y = BLOCK,
            results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="encounter", direction = "1")) +
    theme_minimal() +
    labs( title = "ENCOUNTER by BLOCK",  x = "", y="",
          subtitle = "very little variance in proportion across blocks (as expected)") +
    theme(aspect.ratio = 1)
##############################



# BLOCK / CATEGORY
# GGSTATSPLOT
##############################
x <- grouped_ggbarstats( data = df, x = ENCOUNTER, y = BLOCK,   grouping.var=STIMULUS_CATEGORY,
                    results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="encounter", direction = "1")) + 
    theme_minimal() +
    # labs( title = "",  x = "", y="") + 
    theme(aspect.ratio = 1) + easy_remove_legend()
##############################

(x[[1]] + scale_fill_manual(values = my_palettes(name="encounter", direction = "1")) + labs(title = "CATEGORY A", subtitle = "some variance across category") + 
x[[2]] + scale_fill_manual(values = my_palettes(name="encounter", direction = "1")) + labs(title = "CATEGORY B", subtitle = "alot of variance across category")) / 
(x[[3]] + scale_fill_manual(values = my_palettes(name="encounter", direction = "1")) + labs(title = "CATEGORY C", subtitle = "alot of variance across category") +
x[[4]] + scale_fill_manual(values = my_palettes(name="encounter", direction = "1")) + theme_ggstatsplot() + labs(title = "CATEGORY D", subtitle = "very little variance across category")) + plot_annotation(title = "ENCOUNTER by BLOCK and CATEGORY")



```

**INTERPRETATION**  _Here we see that when aggregated, it appears that more figural categories (C,D) have more engagement. However, when we visualize individual blocks (i.e. stimuli) within a particular category, we see a great deal of variance.  This indicates that features of a particular stimulus may be stronger predictors of engagement than the degree of embellishment.  


#### model fit 

Is _stimulus_ or _category_ a better predictor of engagement?  Here we fit a series of mixed effects logistic regression models, predicting `ENCOUNTER` (reference category = SCROLL) by `STIMULUS_CATEGORY` and `BLOCK` to determine if variance in encounter choice is best explained by the stimulus category (i.e. level of embellishment) or unique features of the stimulus (i.e. embellishment can be engaging or not engaging).

Parameter estimate: intercept = Log Odds of (SCROLL) responses in REFERENCE (exponetiate for odds)
EB1 = Log Odds of ODDS of SCROLL response in CONTROL condition
Parameter estimate: 
 = 
 Log Odds (Log OR; change in odds for correct response in impasse (vs) control [log scale])
 = ODDS RATIO of correct response in IMPASSE (vs) CONTROL
Null hypothesis:
 the odds for a correct response does not change, or decreases
Alternative hypothesis: 
 the odds of a correct response increases

##### DATA SETUP
```{r hypo-category-encounter-fit}

df <- df_graphs %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  filter(STIMULUS != "B0-0") %>%
  select(STIMULUS, STIMULUS_CATEGORY, BLOCK, MAKER_ID, MAKER_GENDER, MAKER_AGE, ENCOUNTER, CHART_LIKE, CHART_TRUST, CHART_BEAUTY, MAKER_DESIGN, MAKER_ALIGN, CHART_INTENT, MAKER_TRUST, MAKER_DATA, MAKER_DESIGN, MAKER_ARGUE, MAKER_POLITIC, MAKER_SELF, PID) %>% 
  mutate(
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY), #REVERSE FACTOR ORDER SO A IS REFERENCE
    ALIGN_Z = datawizard::standardise(MAKER_ALIGN),
    TRUST_Z = datawizard::standardise(CHART_TRUST),
    BEAUTY_Z = datawizard::standardise(CHART_BEAUTY),
    LIKE_Z = datawizard::standardise(CHART_LIKE),
    INTENT_Z = datawizard::standardise(CHART_INTENT),
    MAKERTRUST_Z = datawizard::standardise(MAKER_TRUST),
    DESIGN_Z = datawizard::standardise(MAKER_DESIGN),
    DATA_Z = datawizard::standardise(MAKER_DATA),
    ARGUE_Z = datawizard::standardise(MAKER_ARGUE),
    SELF_Z = datawizard::standardise(MAKER_SELF),
    ABS_POLITIC = datawizard::standardize(abs(MAKER_POLITIC - 50)) #standardize after halfving scale 
  ) %>% 
  droplevels()
    
  
    ## (only used if NOT filtering out B0-0)
    ## RECODE #recode b00 graph as category D [bc it fits in that category]
    # STIMULUS_CATEGORY = fct_recode(STIMULUS_CATEGORY, D="F") 
  

```

```{r}
################## BUILD MODELS #################

# # RANDOM INTERCEPT SUBJECT
# mm.rP <- glmer(ENCOUNTER ~ (1|PID), data = df,family = "binomial")


# # SUBJECT INTERCEPT | FIXED BLOCK 
# ## should be non predictive
# print("ENCOUNTER ~ BLOCK + (1|PID)")
# mm.BrP <- glmer(ENCOUNTER ~ BLOCK + (1|PID), 
#                 data = df,family = "binomial")
# # :: TEST fixed factor 
# compare_performance(mm.rP, mm.BrP, rank = TRUE)
# paste("AIC with fixed effect is lower than random intercept only model?", AIC(logLik(mm.rP)) > AIC(logLik(mm.BrP)) )
# test_lrt(mm.rP,mm.BrP) #same as anova(m0, m1, test = "Chi")
# paste("Likelihood Ratio test is significant? p = ",(test_lrt(mm.rP,mm.BrP))$p[2])
# print("A model with BLOCK is NOT a better fit than (random effect) participant alone")
# car::Anova(mm.BrP, type=2)
# print("BLOCK is NOT significant predictor in the model")
# print("[this is as expected. suggests that we were successful in randomizing stimuli across the blocks]")
```

##### ENCOUNTER ~ CATEOGRY
```{r}

### REFERENCE LEVEL OF ENCOUNTER (0 == ENGAGE)
### STIMULUS CATEGORY A B C D


################## ENCOUNTER ~ CATEGORY #################
f.CrP <-  "ENCOUNTER ~ STIMULUS_CATEGORY + (1|PID)"
mm.CrP <- glmer(ENCOUNTER ~ STIMULUS_CATEGORY + (1|PID), 
                data = df,family = "binomial")
car::Anova(mm.CrP, type = 2)
summary(mm.CrP)
performance(mm.CrP)

m <- mm.CrP
f <- f.CrP
## REPORT 
# report(m)

## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()

## PLOT PRED
plot_model(m, type = "pred", terms = "STIMULUS_CATEGORY") + 
  labs(subtitle = f) + theme_minimal()

## IN PAPER
# tab_model(m)

```

EMBELLISHMENT CATEGORY is significant predictor, predicts 5% variance in ENCOUNTER choice, with only categories C,D significantly different. 



##### ENCOUNTER ~ BEAUTY
```{r}

################## ENCOUNTER ~ BEAUTY #################
f.BrP <-  "ENCOUNTER ~ BEAUTY + (1|PID)"
mm.BrP <- glmer(ENCOUNTER ~ BEAUTY_Z + (1|PID), 
                data = df,family = "binomial")
car::Anova(mm.BrP, type = 2)
summary(mm.BrP)
performance(mm.BrP)

m <- mm.BrP
f <- f.BrP
## REPORT 
# report(mm.CrP)

## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()

## PLOT PRED
plot_model(m, type = "pred", terms = "BEAUTY_Z") + 
  labs(subtitle = f) + theme_minimal()

## IN PAPER
# tab_model(mm.I)


```
BEAUTY is significant predictor, predicts 19% variance in ENCOUNTER choice. Beauty increases probability of scroll, 2.5X the odds for 1 SD in increase in beauty



##### ENCOUNTER ~ LIKE
```{r}

################## ENCOUNTER ~ LIKE #################
f.LrP <-  "ENCOUNTER ~ LIKE + (1|PID)"
mm.LrP <- glmer(ENCOUNTER ~ LIKE_Z + (1|PID), 
                data = df,family = "binomial")
car::Anova(mm.LrP, type = 2)
summary(mm.LrP)
performance(mm.LrP)

m <- mm.LrP
f <- f.LrP
## REPORT 
# report(m)

## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()


## PLOT PRED
plot_model(m, type = "pred", terms = "LIKE_Z") +
  labs(subtitle = f) + theme_minimal()

## IN PAPER
# tab_model(mm.I)


```
LIKE is significant predictor, accounts 25% variance , 2.9X ODDS INCREASE ON LIKE



##### compare
```{r}

compare_performance(mm.CrP, mm.BrP, mm.LrP, rank = TRUE)
anova(mm.CrP, mm.BrP, mm.LrP)

```


##### ENCOUNTER ~ CATEGORY + BEAUTY

```{r}

################## ENCOUNTER ~ CATEGORY + BEAUTY #################
f.BCrP <-  "ENCOUNTER ~ BEAUTY + CATEGORY+ (1|PID)"
mm.BCrP <- glmer(ENCOUNTER ~ BEAUTY_Z + STIMULUS_CATEGORY + (1|PID), 
                data = df,family = "binomial")
car::Anova(mm.BCrP, type = 2)
summary(mm.BCrP)
performance(mm.BCrP)

m <- mm.BCrP
f <- f.BCrP
## REPORT 
# report(m)

## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()


## PLOT PRED
plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "BEAUTY_Z")) + 
  labs(subtitle = f) + theme_minimal()

## IN PAPER
# tab_model(mm.I)


```
sig main effects , explains 22% variance 

##### (BEST) ENCOUNTER ~ CATEGORY + LIKE

```{r}

################## ENCOUNTER ~ CATEGORY + LIKE #################
f.LCrP <-  "ENCOUNTER ~ LIKE + CATEGORY+ (1|PID)"
mm.LCrP <- glmer(ENCOUNTER ~ LIKE_Z + STIMULUS_CATEGORY + (1|PID), 
                data = df,family = "binomial")
car::Anova(mm.LCrP, type = 2)
summary(mm.LCrP)
performance(mm.LCrP)

m <- mm.LCrP
f <- f.LCrP
## REPORT 
# report(m)

## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()


## PLOT PRED
plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "LIKE_Z")) + 
  labs(subtitle = f) + theme_minimal()

## IN PAPER
tab_model(m)
```
Linear combination of LIKE and CATEGORY predicts 28.7% variance, significant like, sig on categories C and D, 3X odds increase on like, ~2.3 - 2.5 on B and C

##### compare
```{r}
### compare
compare_performance(mm.LCrP, mm.BCrP, rank = TRUE)
anova(mm.BrP, mm.LCrP, mm.BCrP)

```
Like + category is better than beauty + category



#### maximal kinda
Since the encounter choice occurred at first exposure to the stimulus we limited our comparisons to the types of social attribution we thought most psychologically-plausible to impact early cognitive processes like attention allocation: \code{MAKER-DESIGN}, \code{CHART-INTENT}, measures we thought most likely to impact a volitional choice including: \code{MAKER-TRUST} and \code{MAKER_DATA}, as well as measures shown in prior work to affect attention via visual salience, including: \code{CHART-BEAUTY} and \code{CHART-LIKE} ~\cite{harrisonInfographicAestheticsDesigning2015}, and degree of embellishment via \code{Category} \cite{alebriEmbellishmentsRevisitedPerceptions2024}. T
```{r}
#BLOCK, MAKER_ID, MAKER_GENDER, MAKER_AGE, ENCOUNTER, CHART_LIKE, CHART_TRUST, CHART_BEAUTY, MAKER_DESIGN, MAKER_ALIGN, CHART_INTENT, MAKER_DATA, MAKER_DESIGN, PID
################## ENCOUNTER ~ CATEGORY * LIKE #################
# f.LxCrP <-  "ENCOUNTER ~ LIKE + CATEGORY + (1|PID)"
# mm <- glmer(ENCOUNTER ~ LIKE_Z + STIMULUS_CATEGORY + MAKER_ID +  MAKER_GENDER + MAKER_AGE + TRUST_Z + BEAUTY_Z + INTENT_Z + DESIGN_Z + DATA_Z + ALIGN_Z  + ARGUE_Z + SELF_Z + (1|PID), 
mm <- glmer(ENCOUNTER ~ DESIGN_Z + INTENT_Z + MAKERTRUST_Z + DATA_Z +  BEAUTY_Z + LIKE_Z + STIMULUS_CATEGORY + (1|PID), 
                data = df,family = "binomial",
             control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               optCtrl=list(maxfun=2e5)))
car::Anova(mm, type = 2)
summary(mm)
performance(mm)

m <- mm
f <- mm

### compare
# compare_performance(mm.CrP, mm.LrP, mm.LCrP, mm.LxCrP, rank = TRUE)
# anova(mm.LCrP, mm.LxCrP)


## REPORT 
# report(m)

## PLOT COEF
plot_model(mm, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) #+
  labs(subtitle = f) + theme_minimal()


## PLOT PRED (only sig model terms)
plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "LIKE_Z"))
plot_model(m, type = "pred", terms = c("LIKE_Z", "STIMULUS_CATEGORY"))

##HAVE TERMS NOT IN MODEL
# plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "LIKE_Z", "MAKER_ID"))
# plot_model(m, type = "pred", terms = c("LIKE_Z", "STIMULUS_CATEGORY", "MAKER_ID"))
# plot_model(m, type = "pred", terms = c("LIKE_Z", "STIMULUS_CATEGORY", "MAKER_ID", " MAKER_AGE"))

##+ 
  # labs(subtitle = f) + theme_minimal()

## IN PAPER
tab_model(mm)


```

##### fish

```{r}
#BLOCK, MAKER_ID, MAKER_GENDER, MAKER_AGE, ENCOUNTER, CHART_LIKE, CHART_TRUST, CHART_BEAUTY, MAKER_DESIGN, MAKER_ALIGN, CHART_INTENT, MAKER_DATA, MAKER_DESIGN, PID
################## ENCOUNTER ~ CATEGORY * LIKE #################
# f.LxCrP <-  "ENCOUNTER ~ LIKE + CATEGORY + (1|PID)"
# mm <- glmer(ENCOUNTER ~ LIKE_Z + STIMULUS_CATEGORY + MAKER_ID +  MAKER_GENDER + MAKER_AGE + TRUST_Z + BEAUTY_Z + INTENT_Z + DESIGN_Z + DATA_Z + ALIGN_Z  + ARGUE_Z + SELF_Z + (1|PID), 
mm <- glmer(ENCOUNTER ~ LIKE_Z + STIMULUS_CATEGORY + MAKER_ID +  MAKER_AGE + (1|PID), 
                data = df,family = "binomial",
             control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               optCtrl=list(maxfun=2e5)))
car::Anova(mm, type = 2)
summary(mm)
performance(mm)

m <- mm
f <- mm

### compare
# compare_performance(mm.CrP, mm.LrP, mm.LCrP, mm.LxCrP, rank = TRUE)
# anova(mm.LCrP, mm.LxCrP)


## REPORT 
# report(m)

## PLOT COEF
plot_model(mm, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) #+
  labs(subtitle = f) + theme_minimal()


## PLOT PRED
plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "LIKE_Z", "MAKER_ID"))
plot_model(m, type = "pred", terms = c("LIKE_Z", "STIMULUS_CATEGORY", "MAKER_ID"))
plot_model(m, type = "pred", terms = c("LIKE_Z", "STIMULUS_CATEGORY", "MAKER_ID", " MAKER_AGE"))

##+ 
  labs(subtitle = f) + theme_minimal()

## IN PAPER
tab_model(mm)


```
best fitting model contained encounter ~ like + category + maker_id, explained 30% variance, 3 sig predictors 
A MODEL adding maker age explains 33% variance 




##### (no) ENCOUNTER ~ CATEGORY X LIKE

```{r}

################## ENCOUNTER ~ CATEGORY * LIKE #################
f.LxCrP <-  "ENCOUNTER ~ LIKE * CATEGORY + (1|PID)"
mm.LxCrP <- glmer(ENCOUNTER ~ LIKE_Z * STIMULUS_CATEGORY + (1|PID), 
                data = df,family = "binomial")
car::Anova(mm.LxCrP, type = 2)
summary(mm.LxCrP)
performance(mm.LxCrP)

m <- mm.LxCrP
f <- f.LxCrP

### compare
# compare_performance(mm.CrP, mm.LrP, mm.LCrP, mm.LxCrP, rank = TRUE)
# anova(mm.LCrP, mm.LxCrP)


## REPORT 
# report(m)

## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()


## PLOT PRED
plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "LIKE_Z")) + 
  labs(subtitle = f) + theme_minimal()

## IN PAPER
# tab_model(mm.I)


```
main effects but interaction is not significant and interaction is not a better fit 



##### (no) ENCOUNTER ~ CATEGORY + LIKE + ALIGN

```{r}

################## ENCOUNTER ~ CATEGORY + LIKE + ALIGN #################
f.ALCrP <-  "ENCOUNTER ~ LIKE + CATEGORY + ALIGN (1|PID)"
mm.ALCrP <- glmer(ENCOUNTER ~ LIKE_Z + ALIGN_Z + STIMULUS_CATEGORY + (1|PID), 
                data = df,family = "binomial")
car::Anova(mm.ALCrP, type = 2)
summary(mm.ALCrP)
performance(mm.ALCrP)

m <- mm.ALCrP
f <- f.ALCrP
## REPORT 
# report(m)


## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()


## PLOT PRED
plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "LIKE_Z", "ALIGN_Z")) + 
  labs(subtitle = f) + theme_minimal()

## IN PAPER
# tab_model(mm.I)

compare_performance(mm.LCrP, mm.ALCrP, rank = TRUE)
anova(mm.LCrP, mm.ALCrP)
```

##### ENCOUNTER ~ CATEGORY + LIKE + TRUST

```{r}

################## ENCOUNTER ~ CATEGORY + LIKE + TRUST #################
f.TLCrP <-  "ENCOUNTER ~ LIKE + CATEGORY + TRUST (1|PID)"
mm.TLCrP <- glmer(ENCOUNTER ~ LIKE_Z + TRUST_Z + STIMULUS_CATEGORY + (1|PID), 
                data = df,family = "binomial")
car::Anova(mm.TLCrP, type = 2)
summary(mm.TLCrP)
performance(mm.TLCrP)

m <- mm.TLCrP
f <- f.TLCrP
## REPORT 
# report(m)


## PLOT COEF
plot_model(m, type = "est", vline.color = "red", show.intercept = TRUE, show.values = TRUE) + 
  labs(subtitle = f) + theme_minimal()


## PLOT PRED
plot_model(m, type = "pred", terms = c("STIMULUS_CATEGORY", "LIKE_Z", "TRUST_Z")) + 
  labs(subtitle = f) + theme_minimal()

## IN PAPER
# tab_model(mm.I)

compare_performance(mm.TLCrP, mm.LCrP, mm.ALCrP, rank = TRUE)
anova(mm.TLCrP, mm.LCrP, mm.ALCrP)
```
trust not sig, model not better 




##### block * category <-- stimulus
```{r}
# 
# # SUBJECT INTERCEPT | FIXED CATEGORY + BLOCK
# print("ENCOUNTER ~ CATEGORY + BLOCK + (1|PID)")
# mm.C_BrP <- glmer(ENCOUNTER ~ STIMULUS_CATEGORY + BLOCK + (1|PID), 
#                 data = df,family = "binomial")
# # :: TEST fixed factor 
# compare_performance(mm.rP, mm.BrP, mm.CrP, mm.C_BrP, rank = TRUE)
# ##anova instead of LRT b/c models are not nested 
# anova(mm.CrP,mm.C_BrP) #same as anova(m0, m1, test = "Chi")
# test_lrt(mm.CrP, mm.C_BrP)
# paste("A model with a linear combination of CATEGORY and BLOCK predicting ENCOUNTER is NOT better fit than a model with only CATEGORY.")
# car::Anova(mm.C_BrP, type = 3)
# print("CATEGORY is a significant predictor in this model, but BLOCK is not")
# 
# 
# # SUBJECT INTERCEPT | FIXED BLOCK * CATEGORY INTERACTION 
# print("ENCOUNTER ~ CATEGORY * BLOCK + (1|PID)")
# mm.CBrP <- glmer(ENCOUNTER ~ STIMULUS_CATEGORY * BLOCK + (1|PID), 
#                 data = df,family = "binomial",
#                control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
#                optCtrl=list(maxfun=2e5)))
# # :: TEST fixed factor 
# compare_performance(mm.BrP, mm.CrP, mm.C_BrP, mm.CBrP, rank = TRUE)
# ##anova instead of LRT b/c models are not nested 
# anova(mm.C_BrP, mm.CBrP)
# test_lrt(mm.C_BrP, mm.CBrP, verbose = TRUE) #same as anova(m0, m1, test = "Chi")
# paste("A model with an interaction of BLOCK * CATEGORY is a significantly better fit than a model with main effects only. (NOTE that block*category == stimulus. Here we fit the interaction so that we can portion variance between block and category, and compare the models as they will be nested)")
# car::Anova(mm.CBrP, type = 3)
# print("In this model, only the interaction is significant. Neither main effects are significant.")
# print("THIS SUGGESTS THAT ENCOUNTER IS BETTER PREDICTED BY THE UNIQUE STIMULUS THAN THE CATEGORY")
# 
# 
# 
# ## SANITY CHECK, MODEL WITH STIMULUS SHOULD MATCH VARIANCE EXPLAINED BY BLOCK*CATEGORY
# # SUBJECT INTERCEPT | FIXED STIMULUS 
# print("SANITY CHECK — MODEL BY STIMULUS")
# print("ENCOUNTER ~ STIMULUS + (1|PID)")
# mm.SrP <- glmer(ENCOUNTER ~ STIMULUS + (1|PID),
#                 data = df,family = "binomial",
#                control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
#                             optCtrl=list(maxfun=2e5)))
# ## :: TEST fixed factor 
# compare_performance(mm.CBrP, mm.SrP, rank = TRUE)
# anova(mm.SrP, mm.CBrP)
# print ("SANITY CHECKED! STIMULUS MODEL SAME FIT AS BLOCK*CATEGORY")
# 
# 
# #### SET BEST MODEL
# m_best <- mm.CBrP

```


#### model describe

```{r hypo-category-encounter-describe}

# ############ DESCRIBE FINAL MODEL ###########
# summary(m_best)
# report(m_best)
# 
# 
# ######### PRINT COEFFICIENTS 
# print("COEFFICIENT ESTIMATES — LOG ODDS")
# tidy(m_best)
# print("COEFFICIENT ESTIMATES — ODDS RATIOS")
# tidy(m_best, exponentiate=TRUE)

``` 

#### model vis
```{r hypo-category-encounter-modelvis}

# ############ VISUALIZE MODEL COEFFICIENTS 
# #SJPLOT | MODEL | ODDS RATIO
# #library(sjPlot)
# plot_model(m_best, type = "est",
#            vline.color = "red", 
#            show.intercept = TRUE, 
#            show.values = TRUE) + theme_minimal() + 
#   labs(title = "Model Predicted Odds Ratio for ENCOUNTER",
#        subtitle = "")
# 
# 
# 
# ############ VISUALIZE MODEL PREDICTIONS
# #SJPLOT | MODEL | PROBABILITIES
# plot_model(m_best, type = "int", mdrt.values = "meansd") + theme_minimal()
# 
# plot_model(m_best, type="emm", 
#            terms = c("BLOCK"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for BLOCK")
# 
# plot_model(m_best, type="emm", 
#            terms = c("STIMULUS_CATEGORY"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for CATEGORY")
# 
# plot_model(m_best, type="emm", 
#            terms = c("BLOCK","STIMULUS_CATEGORY"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for INTERACTION")
# 
# 
# 
# ## MANUAL PREDICTION INTERACTION PLOT [bc stupid sjPlot cant facet argh]
# means <- estimate_means(m_best, at=c("BLOCK","STIMULUS_CATEGORY"), transform = "response",
#                         backend="emmeans")
# m <- as_tibble(means)
# 
# ## CUSTOM PREDICTIONS PLOT
# m %>% ggplot( aes(x = BLOCK, y = Probability, color=STIMULUS_CATEGORY)) +
#   geom_point() +
#   geom_linerange(aes(ymin = CI_low, ymax=CI_high)) + 
#   scale_y_continuous(limits = c(0,1))+
#   facet_wrap(~STIMULUS_CATEGORY) + 
#   theme_minimal() + easy_remove_legend() + 
#   labs(title = "MODEL PREDICTED Probability of ENGAGE (rather than scroll)")

```


### ENCOUNTER ~ LIKE
Here we explore whether another variable `CHART_LIKE` is a better predictor of `ENCOUNTER` than `STIMULUS_CATEGORY`. 

#### visualize

```{r hypo-like-encounter-vis}


df <- df_graphs %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  filter(STIMULUS != "B0-0") %>% 
  select(STIMULUS, STIMULUS_CATEGORY, BLOCK, ENCOUNTER, CHART_LIKE, CHART_TRUST, PID) %>% 
  mutate(
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY), #REVERSE FACTOR ORDER SO A IS REFERENCE
    ENCOUNTER = fct_rev(ENCOUNTER), #REVERSE SO SCROLL IS REFERENCE
    STIM_NUM = str_remove(STIMULUS, regex("B..", dotall = TRUE))
    ## (only used if not filtering out B0-0)
    ## RECODE #recode b00 graph as category D [bc it fits in that category]
    # STIMULUS_CATEGORY = fct_recode(STIMULUS_CATEGORY, D="F") 
  ) %>% droplevels()


## ENCOUNTER BY AVG CHART LIKE
ggbetweenstats(data = df, x = ENCOUNTER, y=CHART_LIKE, color = ENCOUNTER,
               violin.args = list(width = 0, linewidth = 0), #REMOVE violin plot
               results.subtitle = FALSE) + 
  scale_color_manual(values = my_palettes(name="encounter", direction = "-1")) + 
  labs(title = "ENCOUNTER ~ CHART LIKE")


## ENCOUNTER BY AVG CHART LIKE & CATEGORY
grouped_ggbetweenstats(data = df, x = ENCOUNTER, y=CHART_LIKE, color = ENCOUNTER,
                       grouping.var = STIMULUS_CATEGORY,
               violin.args = list(width = 0, linewidth = 0), #REMOVE violin plot
               results.subtitle = FALSE,
               ggplot.component = scale_color_manual(values = my_palettes(name="encounter", direction = "-1"))
               ) + 
  scale_color_manual(values = my_palettes(name="encounter", direction = "-1")) +
  plot_annotation(title = "ENCOUNTER ~ CHART LIKE + CATEGORY")




## ENCOUNTER BY AVG CHART LIKE & BLOCK
grouped_ggbetweenstats(data = df, x = ENCOUNTER, y=CHART_LIKE, color = ENCOUNTER,
                       grouping.var = BLOCK,
               violin.args = list(width = 0, linewidth = 0), #REMOVE violin plot
               results.subtitle = FALSE,
               ggplot.component = scale_color_manual(values = my_palettes(name="encounter", direction = "-1"))
               ) + 
  scale_color_manual(values = my_palettes(name="encounter", direction = "-1")) +
  plot_annotation(title = "ENCOUNTER ~ CHART LIKE + BLOCK")



## ENCOUNTER BY AVG CHART LIKE & STIMULUS
df %>% 
  group_by(BLOCK, STIMULUS_CATEGORY) %>% mutate(m=mean(CHART_LIKE)) %>%
  ggplot( aes(x = BLOCK, y = CHART_LIKE, color = ENCOUNTER)) + 
  geom_boxplot(width = 0.3, fill = "white", position = position_dodge(width=1)) + 
  geom_jitter(alpha = 0.2, position = position_dodge(width=1)) +
  scale_fill_manual(values = my_palettes(name="encounter", direction = "-1")) +
  scale_color_manual(values = my_palettes(name="encounter", direction = "-1")) +
  facet_wrap(~STIMULUS_CATEGORY) + 
  theme_minimal() + easy_remove_legend() + 
  labs(title = "ENCOUNTER by CHART LIKE for BLOCK & STIMULUS")
  

```

#### model fit 

Is `CHART_LIKE` a better predictor of engagement?  Here we fit a series of mixed effects logistic regression models, predicting `ENCOUNTER` (reference category = SCROLL) by `CHART_LIKE` and comparing this to the best fit model of `STIMULUS_CATEGORY` and `BLOCK` to determine if variance in encounter choice is better explained by the stimulus category (i.e. level of embellishment) or whether the participant likes the chart. 


```{r hypo-like-encounter-fit}

df <- df_graphs %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  filter(STIMULUS != "B0-0") %>% 
  select(STIMULUS, STIMULUS_CATEGORY, BLOCK, ENCOUNTER, CHART_LIKE, CHART_TRUST, PID) %>% 
  mutate(
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY), #REVERSE FACTOR ORDER SO A IS REFERENCE
    ENCOUNTER = fct_rev(ENCOUNTER), #REVERSE SO SCROLL IS REFERENCE
    CHART_LIKE_Z = datawizard::standardise(CHART_LIKE) ## to avoid model non converge
    ## (only used if not filtering out B0-0)
    ## RECODE #recode b00 graph as category D [bc it fits in that category]
    # STIMULUS_CATEGORY = fct_recode(STIMULUS_CATEGORY, D="F") 
  ) %>% droplevels()



################## BUILD MODELS #################

## BEST FIT MODEL OF CATEGORY * BLOCK
# SUBJECT INTERCEPT | FIXED BLOCK * CATEGORY INTERACTION 
print("ENCOUNTER ~ CATEGORY * BLOCK + (1|PID)")
mm.CBrP <- glmer(ENCOUNTER ~ STIMULUS_CATEGORY * BLOCK + (1|PID), 
                data = df,family = "binomial",
               control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               optCtrl=list(maxfun=2e5)))



# SUBJECT INTERCEPT | FIXED CHART_LIKE
print("ENCOUNTER ~ CATEGORY + (1|PID)")
mm.LrP <- glmer(ENCOUNTER ~ CHART_LIKE_Z + (1|PID), 
                data = df,family = "binomial")
# :: TEST fixed factor 
compare_performance(mm.CBrP, mm.LrP, rank = TRUE)
##anova instead of LRT b/c models are not nested 
anova(mm.CBrP, mm.LrP) #same as anova(m0, m1, test = "Chi")
paste("A model with CHART_LIKE predicting ENCOUNTER is a better fit than a model with CATEGORY*BLOCK, though not significantly so")
car::Anova(mm.LrP, type = 3)
print("CHART_LIKE is a significant predictor in this model")




# SUBJECT INTERCEPT | FIXED CHART_LIKE + STIMULUS_CATEGORY * BLOCK
print("ENCOUNTER ~ CATEGORY * BLOCK + (1|PID)")
mm.L_CBrP <- glmer(ENCOUNTER ~ CHART_LIKE_Z + STIMULUS_CATEGORY * BLOCK + (1|PID), 
                data = df,family = "binomial",
               control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               optCtrl=list(maxfun=2e5)))
# :: TEST fixed factor 
compare_performance(mm.LrP, mm.CBrP, mm.L_CBrP, rank = TRUE)
##anova instead of LRT b/c models are not nested 

### CHECK AGAINST JUST CHART LIKE
anova(mm.L_CBrP, mm.LrP)
test_lrt(mm.L_CBrP, mm.LrP, verbose = TRUE) #same as anova(m0, m1, test = "Chi")
paste("A model adding the interaction of BLOCK * CATEGORY to CHART_LIKE is a significantly better fit than a model with the CHART_LIKE alone")

### CHECK AGAINST IXN MODEL
anova(mm.L_CBrP, mm.CBrP)
test_lrt(mm.L_CBrP, mm.CBrP, verbose = TRUE) #same as anova(m0, m1, test = "Chi")
paste("A model adding CHART LIKE to the interaction of BLOCK * CATEGORY is a significantly better fit than a model with the interaction only.")

### EXAMINE THIS MODEL
car::Anova(mm.L_CBrP, type = 3)
print("In this model, the CHART_LIKE variable is significant, along with the STIMULUS_CATEGORY and interaction of CATEGORY & BLOCK")
print("THIS SUGGESTS THAT ENCOUNTER IS BETTER PREDICTED BY THE UNIQUE STIMULUS THAN THE CATEGORY")



#### SET BEST MODEL
m_best <- mm.L_CBrP

```


#### model describe

```{r hypo-like-encounter-describe}

############ DESCRIBE FINAL MODEL ###########
summary(m_best)
report(m_best)


######### PRINT COEFFICIENTS 
# print("COEFFICIENT ESTIMATES — LOG ODDS")
# tidy(m_best)
print("COEFFICIENT ESTIMATES — ODDS RATIOS")
tidy(m_best, exponentiate=TRUE)

``` 




#### model vis
```{r hypo-like-encounter-modelvis}

############ VISUALIZE MODEL COEFFICIENTS 
#SJPLOT | MODEL | ODDS RATIO
#library(sjPlot)
plot_model(m_best, type = "est",
           vline.color = "red", 
           show.intercept = TRUE, 
           show.values = TRUE) + theme_minimal() + 
  labs(title = "Model Predicted Odds Ratio for ENCOUNTER",
       subtitle = "")



############ VISUALIZE MODEL PREDICTIONS
#SJPLOT | MODEL | PROBABILITIES

plot_model(m_best, type="pred", 
           terms = c("CHART_LIKE_Z"), ci.lvl = 0.95) + theme_minimal() + 
  labs(title = "Estimated Marginal Means on ENCOUNTER",
       subtitle = "Probability of ENAGAGE steadily increases as a function of CHART_LIKE",
       caption = "predicted effect of CHART LIKE holding CATEGORY and BLOCK at weighted average")

plot_model(m_best, type="pred", 
           terms = c("CHART_LIKE_Z", "STIMULUS_CATEGORY"), ci.lvl = 0.95) + theme_minimal() + 
  labs(title = "Estimated Marginal Means on ENCOUNTER",
       subtitle = "Increases as a function of CHART_LIKE, with CATEGORY A (least embellished) lower",
       caption = "predicted effect of CHART LIKE AT CATEGORY holding BLOCK at weighted average")


plot_model(m_best, type="pred", 
           terms = c("CHART_LIKE_Z", "BLOCK"), ci.lvl = 0.95) + theme_minimal() + 
      labs(title = "Estimated Marginal Means on ENCOUNTER",
           subtitle = "Steady increases by CHART_LIKE, little diff by block",
          caption = "predicted effect of CHART LIKE AT BLOCK holding CATEGORY at weighted average")

plot_model(m_best, type="pred", 
           terms = c("CHART_LIKE_Z","STIMULUS_CATEGORY","BLOCK"), ci.lvl = 0.95) + theme_minimal() + 
  labs(title = "Estimated Marginal Means on ENCOUNTER",
       subtitle = "Steady increase by CHART_LIKE, with CATEGORY differences differing by BLOCK",
       caption = "predicted effect conditioned on all predictors")


## MANUAL PREDICTION INTERACTION PLOT [bc sjPlot cant facet argh]
means <- estimate_means(m_best, at=c("CHART_LIKE_Z","BLOCK","STIMULUS_CATEGORY"), transform = "response",
                        backend="emmeans")
m <- as_tibble(means)

## CUSTOM PREDICTIONS PLOT
m %>% ggplot( aes(x = CHART_LIKE_Z, y = Probability, color=STIMULUS_CATEGORY, fill=STIMULUS_CATEGORY)) +
  geom_ribbon(aes(x=CHART_LIKE_Z, ymin = CI_low, ymax=CI_high), alpha= 0.5) + 
  geom_linerange(aes(ymin = CI_low, ymax=CI_high)) +
  geom_point() +
  scale_y_continuous(limits = c(0,1))+
  facet_grid(BLOCK ~ STIMULUS_CATEGORY) +
  # facet_wrap(~BLOCK) +
  theme_minimal() + easy_remove_legend() + 
  labs(title = "MODEL PREDICTED Probability of ENGAGE (rather than scroll)",
      subtitle = "Steady increase by CHART_LIKE, with CATEGORY differences differing by BLOCK",
       caption = "ENCONTER ~ CHART_LIKE_Z + CATEGORY * BLOCK + (1|PID")

```


### WIP DATA AND DESIGN BY CATEGORY and BLOCK

#### visualization

```{r}

df <- df_graphs %>% 
  mutate(
    ## reverse order of MAKER_DATA, because scale ranged from 0=expert to 100=layperson
    ## we want the reverse 
    ## chose NOT to z-score data, bc we want the data in terms of the original scale 
    r_MAKER_DATA = reverse_scale(MAKER_DATA),
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY)
  ) %>% filter(STIMULUS!="B0-0") %>% 
  group_by(STIMULUS_CATEGORY, BLOCK) %>% 
  mutate(
    m=mean(MAKER_DATA), 
    md=median(MAKER_DATA)
  )

df %>% ggplot(aes(x=MAKER_DATA,  y=BLOCK))+
  geom_density_ridges( scale = 0.75) + 
  # ##MEDIAN
  # stat_summary(fun=median, geom="text", colour="red",  fontface = "bold", size = 2.5,
  #              vjust=+2, hjust = 0, aes( label=round(md, digits=0)))+
  # stat_summary(fun=median, geom="point", shape=20, size=3, color="red", fill="red") +
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(m, digits=0)))+
  stat_summary(fun="mean", geom="point", shape=20, size=3, color="blue", fill="blue") +
  facet_wrap(~STIMULUS_CATEGORY)+ 
  labs(title = "MAKER_DATA by BLOCK AND CATEGORY", caption="(mean in blue)")+
  theme_minimal() + easy_remove_legend()




```

#### models

##### MAKER_DATA BY CATEGORY

```{r model-DATA-BY-CATEGORY}

### LINEAR MIXED EFFECTS MODEL ##################

df <- df_graphs %>% 
  mutate(
    ## reverse order of MAKER_DATA, because scale ranged from 0=expert to 100=layperson
    ## we want the reverse 
    ## chose NOT to z-score data, bc we want the data in terms of the original scale 
    r_MAKER_DATA = reverse_scale(MAKER_DATA),
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY)
  ) %>% filter(STIMULUS!="B0-0")

## SET CONTRASTS
# contrasts(df$MAKER_ID) <-car::contr.Treatment(levels(df$MAKER_ID)) # intercept first group mean; coeff dif from first

## DEFINE MODEL
mr1 <-lmer(r_MAKER_DATA ~  (1|PID) , data=df)
mr2 <-lmer(r_MAKER_DATA ~  (1|PID) + (1|STIMULUS), data=df)
mm1 <-lmer(r_MAKER_DATA ~  STIMULUS +  (1|PID) , data=df)
mm2 <-lmer(r_MAKER_DATA ~  STIMULUS_CATEGORY +  (1|PID) , data=df)
mm3 <-lmer(r_MAKER_DATA ~  BLOCK +  (1|PID) , data=df)
mm4 <-lmer(r_MAKER_DATA ~  STIMULUS_CATEGORY*BLOCK +  (1|PID) , data=df)



## sig diff between categories?
print("PREDICTED BY CATEGORY?")
print("we do expect to see some difference between categories, likely between A and D, however, variance within each category should be substantial")
f <- "MAKER_DATA ~ STIMULUS_CATEGORY"
anova(mm2)
r2 = r2(mm2)
means <- estimate_means(mm2, at="STIMULUS_CATEGORY")
contrasts <- estimate_contrasts(mm2, contrast="STIMULUS_CATEGORY",method="pairwise")
plot(contrasts, means) + 
    geom_text(aes(x=means$STIMULUS_CATEGORY, y=means$Mean, label=round(means$Mean,2)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption =f, y="predicted MAKER DATA COMPETENCY \n (0=layperson, 100=expert)", 
                         subtitle=paste0("R2 marginal ",round(r2$R2_marginal*100,2),"%"))
    


print("PREDICTED BY BLOCK")
print("we do not expect to see sig diffs btwn blocks if they are aesthetically balanced")
f <- "MAKER_DATA ~ STIMULUS_CATEGORY * BLOCK + (1|PID)"
anova(mm3)
r2 = r2(mm3)
means <- estimate_means(mm3, at="BLOCK")
contrasts <- estimate_contrasts(mm3, contrast="BLOCK",method="pairwise")
plot(contrasts, means) + 
    geom_text(aes(x=means$BLOCK, y=means$Mean, label=round(means$Mean,2)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption =f, y="predicted MAKER DATA COMPETENCY \n (0=layperson, 100=expert)", 
                         subtitle=paste0("R2 marginal ",round(r2$R2_marginal*100,2),"%"))
    





print("PREDICTED BY INTERACTION")
print("")
f <- "MAKER_DATA ~ STIMULUS_CATEGORY"
anova(mm4)
r2 = r2(mm4)
means <- estimate_means(mm4, at=c("STIMULUS_CATEGORY","BLOCK"))
contrasts <- estimate_contrasts(mm4, c("STIMULUS_CATEGORY","BLOCK"),method="pairwise")
plot(contrasts, means) + facet_wrap("BLOCK")+
    # geom_text(aes(x=means$BLOCK, y=means$Mean, label=round(means$Mean,2)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption =f, y="predicted MAKER DATA COMPETENCY \n (0=layperson, 100=expert)", 
                         subtitle=paste0("R2 marginal ",round(r2$R2_marginal*100,2),"%"))
    
## TEST MODEL FIT 
# test_performance(mm2,mm3)    
# test_performance(mm2,mm4)    
# test_performance(mm3,mm4)    
anova(mm2,mm3)
print("the model with CATEGORY is not a significantly better fit than the model with BLOCK")
test_likelihoodratio(mm2, mm4)
print("interaction better fit than category")
test_likelihoodratio(mm3, mm4)
print("interaction better fit than block")

compare_models(mm2,mm3,mm4)
compare_performance(mr1, mr2, mm1,mm2,mm3,mm4, rank=TRUE)
f <- "MAKER_DATA ~ STIMULUS_CATEGORY * BLOCK + (1|PID)"


## PLOT BEST FIT MODEL PREDICTIONS
(p_data <- cat_plot(mm4, pred = BLOCK, modx = STIMULUS_CATEGORY,
         geom = "line", interval.geom= "linerange", 
         interval=TRUE, int.type = "confidence", int.width = 0.95, robust = TRUE,
         plot.points = FALSE) + 
    facet_wrap(~STIMULUS_CATEGORY) + 
    labs(title = "LMER Predictions | MAKER_DATA by BLOCK X CATEGORY", 
         caption = f, 
         y="MAKER_DATA \n 0(layerpson) --> 100 (professional)") + easy_remove_legend()
)

# if(GRAPH_SAVE){
#   ggsave(plot = p_data, path="figs/level_category/models", filename =paste0("lmer_maker_DATA_by_stimulus_category","_ixn.png"), units = c("in"))
# }


## PLOT MODEL PARAMETERS
plot_model(mm4, type = "est",
        # show.intercept = TRUE,
        show.values = TRUE,
        value.offset = .25,
        show.p = TRUE
) + theme_minimal() + labs(caption=f)
```

**INTERPRETATION** *Here we see that a linear mixed effects model,
predicting MAKER_DATA by the interaction of STIMULUS_CATEGORY and BLOCK
indicates that ratings of maker data competencies do NOT vary
consistently as a function of CATEGORY (i.e. the degree of
'embellishment'). Although the degree of embellishment within a block
(A,B,C,D) is the same, the ratings of maker data competency vary. This
pattern is particularly salient in categories C and D (with more
embellishment). These data suggest that social inferences about a
maker's data competency are not made solely based on the amount of
embellishment, but rather, in response to the particular features of the
visualization. A highly embellished chart might be rated with relatively
high high data competency (e.g. B3-D) or lower data competency (eg.
B5-D).*

##### MAKER_DESIGN BY CATEGORY

```{r model-DESIGN-BY-CATEGORY}

df <- df_graphs %>% 
  mutate(
    ## reverse order of MAKER_DATA, because scale ranged from 0=expert to 100=layperson
    ## we want the reverse 
    ## chose NOT to z-score data, bc we want the data in terms of the original scale 
    r_MAKER_DESIGN = reverse_scale(MAKER_DESIGN),
    STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY)
  ) %>% filter(STIMULUS!="B0-0")


## DEFINE MODEL
mr1 <-lmer(r_MAKER_DESIGN ~  (1|PID) , data=df)
mr2 <-lmer(r_MAKER_DESIGN ~  (1|PID) + (1|STIMULUS), data=df)
mm1 <-lmer(r_MAKER_DESIGN ~  STIMULUS +  (1|PID) , data=df)
mm2 <-lmer(r_MAKER_DESIGN ~  STIMULUS_CATEGORY +  (1|PID) , data=df)
mm3 <-lmer(r_MAKER_DESIGN ~  BLOCK +  (1|PID) , data=df)
mm4 <-lmer(r_MAKER_DESIGN ~  STIMULUS_CATEGORY*BLOCK +  (1|PID) , data=df)



## sig diff between categories?
print("PREDICTED BY CATEGORY?")
print("we do expect to see some difference between categories, likely between A and D, however, variance within each category should be substantial")
f <- "MAKER_DESIGN ~ STIMULUS_CATEGORY"
anova(mm2)
r2 = r2(mm2)
means <- estimate_means(mm2, at="STIMULUS_CATEGORY")
contrasts <- estimate_contrasts(mm2, contrast="STIMULUS_CATEGORY",method="pairwise")
plot(contrasts, means) + 
    geom_text(aes(x=means$STIMULUS_CATEGORY, y=means$Mean, label=round(means$Mean,2)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption =f, y="predicted MAKER DESIGN COMPETENCY \n (0=layperson, 100=expert)", 
                         subtitle=paste0("R2 marginal ",round(r2$R2_marginal*100,2),"%"))
    


print("PREDICTED BY BLOCK")
print("we do not expect to see sig diffs btwn blocks if they are aesthetically balanced")
f <- "MAKER_DESIGN ~ BLOCK"
anova(mm3)
r2 = r2(mm3)
means <- estimate_means(mm3, at="BLOCK")
contrasts <- estimate_contrasts(mm3, contrast="BLOCK",method="pairwise")
plot(contrasts, means) + 
    geom_text(aes(x=means$BLOCK, y=means$Mean, label=round(means$Mean,2)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption =f, y="predicted MAKER DESIGN COMPETENCY \n (0=layperson, 100=expert)", 
                         subtitle=paste0("R2 marginal ",round(r2$R2_marginal*100,2),"%"))
    



print("PREDICTED BY INTERACTION")
print("")
f <- "MAKER_DESIGN ~ STIMULUS_CATEGORY * BLOCK + (1|PID)"
anova(mm4)
r2 = r2(mm4)
means <- estimate_means(mm4, at=c("BLOCK","STIMULUS_CATEGORY"))
contrasts <- estimate_contrasts(mm4, c("BLOCK","STIMULUS_CATEGORY"),method="pairwise")
plot(contrasts, means) + facet_wrap("STIMULUS_CATEGORY")+
    # geom_text(aes(x=means$BLOCK, y=means$Mean, label=round(means$Mean,2)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption =f, y="predicted MAKER DESIGN COMPETENCY \n (0=layperson, 100=expert)", 
                         subtitle=paste0("R2 marginal ",round(r2$R2_marginal*100,2),"%"))
    

## TEST MODEL FIT 
# test_performance(mm2,mm3)    
# test_performance(mm2,mm4)    
# test_performance(mm3,mm4)    
anova(mm2,mm3)
print("the model with CATEGORY is not a significantly better fit than the model with BLOCK")
test_likelihoodratio(mm2, mm4)
print("interaction better fit than category")
test_likelihoodratio(mm3, mm4)
print("interaction better fit than block")

compare_models(mm2,mm3,mm4)
compare_performance(mr1, mr2, mm1,mm2,mm3,mm4, rank=TRUE)
f <- "MAKER_DATA ~ STIMULUS_CATEGORY * BLOCK + (1|PID)"


## PLOT BEST FIT MODEL PREDICTIONS
(p_design <- cat_plot(mm4, pred = BLOCK, modx = STIMULUS_CATEGORY,
         geom = "line", interval.geom= "linerange", 
         interval=TRUE, int.type = "confidence", int.width = 0.95, robust = TRUE,
         plot.points = FALSE) + 
    facet_wrap(~STIMULUS_CATEGORY) + 
    labs(title = "LMER Predictions | MAKER_DESIGN by BLOCK X CATEGORY", 
         caption = f, 
         y="MAKER_DESIGN \n 0(layerpson) --> 100 (professional)") + easy_remove_legend()
)

# if(GRAPH_SAVE){
#   ggsave(plot = p_design, path="figs/level_category/models", filename =paste0("lmer_maker_DESIGN_by_stimulus_category","_ixn.png"), units = c("in"))
# }


## PLOT MODEL PARAMETERS
plot_model(mm4, type = "est",
        # show.intercept = TRUE,
        show.values = TRUE,
        value.offset = .25,
        show.p = TRUE
) + theme_minimal() + labs(caption=f)
```

**INTERPRETATION** *Here we see that a linear mixed effects model,
predicting MAKER_DESIGN by the combination of STIMULUS_CATEGORY and
BLOCK indicates that ratings of maker design competencies do NOT vary
consistently as a function of CATEGORY (i.e. the degree of
'embellishment'). Although the degree of embellishment within a block
(A,B,C,D) is the same, the ratings of maker design competency vary. This
pattern is particularly salient in category C. These data suggest that
social inferences about a maker's design competency are not made solely
based on the amount of embellishment, but rather, in response to the
particular features of the visualization. A highly embellished chart
might be rated with relatively high design competency (e.g. B2-C) or
lower data competency (eg. B5-C).*



# RESOURCES

-   custom color palettes:
    <https://www.r-bloggers.com/2022/06/custom-colour-palettes-for-ggplot2/>
-   lessR donuts <https://r-charts.com/part-whole/donut-chart/>
-   GGSANKEY <https://github.com/davidsjoberg/ggsankey>
-   GGALLUVIAL
    <https://corybrunson.github.io/ggalluvial/articles/ggalluvial.html>
-   variable standardization [variable (vs) participant]
    :<https://cran.r-project.org/web/packages/datawizard/vignettes/standardize_data.html>
-   contrasts:
-   UCLA:<https://stats.oarc.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables>
-   <https://phillipalday.com/stats/lazy-contrasts.html>
-   level naming with contrasts :<https://rpubs.com/bbolker/5335>
-   ggdist slab normaliztion
    <https://mjskay.github.io/ggdist/articles/thickness.html>
-   visualizing regression models visreg
    <https://pbreheny.github.io/visreg/index.html>
- troubleshooting model convergence issues https://rstudio-pubs-static.s3.amazonaws.com/33653_57fc7b8e5d484c909b615d8633c01d51.html
- understanding marginal effects https://strengejacke.github.io/ggeffects/articles/ggeffects.html#summary-of-most-important-points