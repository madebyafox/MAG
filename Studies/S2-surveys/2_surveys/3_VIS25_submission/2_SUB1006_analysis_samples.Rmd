---
title: "SUBMISSION 1006 — SAMPLE-level analysis"
author: "ANONYMIZED"
date: "2024-02-24"
output:
  html_document:
    theme: flatly
    code_folding: hide
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    toc_depth: 6
  pdf_document:
    toc: yes
    toc_depth: '5'
always_allow_html: yes
font-family: DejaVu Sans
mainfont: DejaVu Sans
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#UTILITIES
library(Hmisc) # %nin% operator
library(psych) #describe()
library(tidyverse) #all the things
library(magrittr) #special pipes like %<>%
library(summarytools) #data quality
library(lubridate) #dealing with dates
library(tinytable) ##sparkline tables 
library(webshot2) ##saving sparkline tables

#EDA
library(qacBase)

#VIZ
library(kableExtra) #printing tables
library(ggformula) #regression syntax viz
# library(vcd) #mosaic plots
# library(vcdExtra) #mosaic plot helpers
library(ggstatsplot) #dummies
library(gghalves) #half boxplots 
library(GGally) #extends ggplot for EDA 
library(corrplot) #sophisticated correlation plots
library(ggeasy) #easy labelling
library(ggh4x) #guides [dual axes]
library(patchwork) #multi-plot layout
library(ggdist) #raincloud plots and other distributionals
library(ggridges) #ridge plots
library(viridis) #color palettes
library(RColorBrewer) #color palettes
library(plotly) # interactive graphs
library(paletteer) #more palettes
library(lessR) ##very pretty donuts 
library(ggsankey) ## ggplot2 sankey extension
library(interactions) ##easier regression ixn plots.srlsy
library(ggraph) ## node link diagrams
library(tidygraph)



#MODELLING
library(jtools) #Social Science regression utilities
library(easystats) #modelling helpers
library(see)
library(sjPlot)
library(lme4)
library(lmerTest) #for CIs in glmer
# library(mixed) ## utilities for glmers 
library(equatiomatic) ## extracting model formula
library(latex2exp) ## extracting and printing model formula

#STATISTICAL TESTS 
library(kSamples) #AD K-SAMPLE TEST (for distribution comparison)
library(rstatix) #FRIEDMAN'S TESTS and effect sizes 

#CONFIG
options(readr.show_col_types = FALSE) #don't show coltypes on read_csv
n_blocks = 6

## IMPORTANT 
GRAPH_SAVE = TRUE #set to true to generate all the SD graphs and save to folders 
source("graphing_functions.R") #import graphing palettes and custom functions



```

In the [SUBMISSION 1006] studies, participants completed an
*attribution eliciation* survey, asking questions about their social inferences drawn from  (5) stimulus images (data visualizations). Each participant was
randomly assigned to one of 6 stimulus blocks, each containing 1 image
from each of (4) 'embellishment categories' (ranging from most abstract
to most figural). Each participant started by responding to questions
for a single 'common' stimulus (B0-0). Two participant recruitment pools
were used: (S1) Tumblr (to replicate and compare survey results to Morgenstern et. al interviews
with participants sourced from Tumblr), and (2) a broader sample recruited from Prolific. 

**This notebook includes analysis and comparison of data collected in Study 1 (Tumblr sample) and Study 2 (Prolific data-collar vs. blue-collar samples).**

# SETUP

*We start by importing data files previously wrangled in
`0_SUB1006_wrangling.Rmd`.*

### Import References

```{r import-refs, message=FALSE, warning = FALSE}

############## IMPORT REFERENCE FILES
ref_stimuli <- readRDS("data/input/REFERENCE/ref_stimuli.rds")
ref_surveys <- readRDS("data/input/REFERENCE/ref_surveys.rds")
ref_labels <- readRDS("data/input/REFERENCE/ref_labels.rds")
ref_labels_abs <- readRDS("data/input/REFERENCE/ref_labels_abs.rds")

############## SETUP Graph Labels
ref_stim_id <- levels(ref_stimuli$ID)
ref_cat_questions <- c("MAKER_ID","MAKER_AGE","MAKER_GENDER")
ref_free_response <- c("MAKER_DETAIL", "MAKER_EXPLAIN", "TOOL_DETAIL", "CHART_EXPLAIN")
ref_conf_questions <- c("MAKER_CONF", "AGE_CONF", "GENDER_CONF", "TOOL_CONF")
ref_sd_questions <- rownames(ref_labels)
ref_sd_questions_abs <- rownames(ref_labels_abs)
  

# ref_blocks <- c("block1", "block2", "block3", "block4", "block5", "block6")
ref_blocks <- c(1,2,3,4,5,6)

```

### Import Data

Since data for all surveys were wrangled in a single cleaning file, here we filter all dataframes to only include data from participants in the (S1) Tumblr and (S2) Prolific data vs. blue collar samples.  Also, we filter data to only include data for STIMULUS BLOCK 1, because Study 2 only include BLOCK 1

TODO:: return to these and remove unneeded files

```{r import-data}

# 1 row per participant — wide
df_data <- readRDS("data/output/Study_1_2_3/df_data.rds")


# 1 row per participant — demographic
df_participants <- readRDS("data/output/Study_1_2_3/df_participants.rds")
df_participants_S4 <- readRDS("data/output/Study_4/df_participants_S4.rds")

# sd questions LONG
df_sd_questions_long <- readRDS("data/output/Study_1_2_3/df_sd_questions_long.rds")

# all questions LONG
df_graphs <- readRDS("data/output/Study_1_2_3/df_graphs.rds")





### CREATE BLOCK 1 DATAFRAMES (bc data/blue collar was only run on Block 1)
df_b1_data <- df_data %>% filter(Assigned.Block==1) %>% droplevels()


## FILTER FOR BLOCK 1 PARTICIPANTS AND JOIN S1_3 & S4
df_b1_participants <- df_participants %>% filter(Assigned.Block==1) %>% droplevels()
df_b1_participants_S4 <- df_participants_S4 %>% filter(Assigned.Block==1) %>% droplevels()
df_b1_participants <- rbind(df_b1_participants, df_b1_participants_S4)


df_b1_sds_long <- df_sd_questions_long%>% filter(Assigned.Block==1) %>% droplevels()
df_b1_graphs <- df_graphs %>%  filter(Assigned.Block==1) %>% droplevels()


############## IMPORT DATA FILES

# #1 row per participant — WIDE
# df_all <- readRDS("data/output/df_data.rds") 
# df_data <- df_all %>% filter(Sample !="GENERAL") %>% filter(Assigned.Block ==1) %>% droplevels()
#  
# #1 row per participant — demographic
# df_participants <- readRDS("data/output/df_participants.rds") %>% filter(Sample !="GENERAL") %>% filter(Assigned.Block ==1) %>% droplevels()
# 
# # #1 row per question — LONG
# # df_questions <- readRDS("data/output/df_questions.rds") 
# # 
# # # only sd questions WIDE
# # df_sd_questions_wide <- readRDS("data/output/df_sd_questions_wide.rds")
# # 
# # #multiselect format for tools Question
# df_tools <- readRDS("data/output/df_tools.rds") %>% filter(Sample !="GENERAL") %>% filter(Assigned.Block ==1) %>% droplevels()
# # 
# # # multiselect format for action Question
# df_actions <- readRDS("data/output/df_actions.rds") %>% filter(Sample !="GENERAL") %>% filter(Assigned.Block ==1) %>% droplevels()
# # # # df_graphs_full <- readRDS("data/output/df_graphs_full.rds") #includes free response data
# # 
# # only categorical and numeric questions
# df_graphs_ALL <- readRDS("data/output/df_graphs.rds") 
# df_graphs <- df_graphs_ALL %>%  filter(Sample !="GENERAL") %>% filter(Assigned.Block ==1) %>% droplevels()
# # only sd questions LONG
# 
# df_sd_questions_long <- readRDS("data/output/df_sd_questions_long.rds")%>% filter(Sample !="GENERAL") %>% filter(Assigned.Block ==1) %>% droplevels()
# df_sd_questions_long_ALL <- readRDS("data/output/df_sd_questions_long.rds")
# # 
# # ### DATA FILES WITH (VARIABLE-WISE) Z-SCORED SEMANTIC DIFFERENTIAL QS 
# # df_graphs_z <- readRDS("data/output/df_graphs_z.rds") #only categorical and numeric questions
# # df_sd_questions_long_z <- readRDS("data/output/df_sd_questions_long_z.rds") # only sd questions LONG
# # 
# # 
# # ### DATA FILES WITH ABSOLUTE VALUE SEMANTIC DIFFERENTIAL QS 
# # df_graphs_abs <- readRDS("data/output/df_graphs_abs.rds") #only categorical and numeric questions
# # df_sd_questions_long_abs <- readRDS("data/output/df_sd_questions_long_abs.rds") # only sd questions LONG

```



# SAMPLE

## TODO Describe Sample 
```{r describe-sample}


print("df_b1_participants")
table(df_b1_participants$Assigned.Block, df_b1_participants$Sample, df_b1_participants$Study)


```

## TODO Sample Demographics

```{r sample-size}

df <- df_participants

## FOR DESCRIPTIVES PARAGRAPH
# #PROLIFIC
df.p <- df %>% filter(Distribution == "PROLIFIC")
desc.gender.p <- table(df.p$D_gender) %>% prop.table()
names(desc.gender.p) <- levels(df.p$D_gender)
p_participants <- nrow(df.p)

# #TUMBLR
df.t <- df %>% filter(Distribution == "TUMBLR")
desc.gender.t <- table(df.t$D_gender) %>% prop.table()
names(desc.gender.t) <- levels(df.t$D_gender)
t_participants <- nrow(df.t)


```

Combined, a total of `r p_participants + t_participants` participants
were recruited from US-located English speaking users of (S1) TUMBLR (n =
`r t_participants`) and (S2) PROLIFIC (n = `r p_participants`).

`r t_participants` individuals from Tumblr participated in Study 1, (
`r round(desc.gender.t[["Female"]],2)*100`% Female,
`r round(desc.gender.t[["Male"]],2)*100`% Male,
`r round(desc.gender.t[["Non-binary / third gender"]],2)*100`%
Non-binary,
`r (round((desc.gender.t[["Prefer not to say"]] + desc.gender.t[["Prefer to self-describe"]]),2)) * 100`%
Other). Note that a higher proportion of participants recruited from
TUMBLR report identities other than cis-gender Female and cis-gender
Male.

`r p_participants` individuals from PROLIFIC participated in Study 2, (
`r round(desc.gender.p[["Female"]],2)*100`% Female,
`r round(desc.gender.p[["Male"]],2)*100`% Male,
`r round(desc.gender.p[["Non-binary / third gender"]],2)*100`%
Non-binary,
`r (round((desc.gender.p[["Prefer not to say"]] + desc.gender.p[["Prefer to self-describe"]]),2)) * 100`%
Other).



## TODO Study Response Time

```{r demo-response-time}

df <- df_participants

## for descriptives paragraph
p.desc.duration <- psych::describe(df %>% filter(Distribution=="PROLIFIC") %>% pull(duration.min))

t.desc.duration <- psych::describe(df %>% filter(Distribution=="TUMBLR") %>% pull(duration.min))

a.desc.duration <- psych::describe(df %>% pull(duration.min))

```

STUDY 1: TUMBLR SAMPLE (n = `r t.desc.duration$n` ) participant response times
ranged from `r t.desc.duration$min` to `r t.desc.duration$max` minutes,
with a mean response time of `r round(t.desc.duration$mean,2)` minutes,
SD = `r (round(t.desc.duration$sd,2))`.

STUDY 2 : PROLIFIC SAMPLE (n = `r p.desc.duration$n` ) participant response times
ranged from `r p.desc.duration$min` to `r p.desc.duration$max` minutes,
with a mean response time of `r round(p.desc.duration$mean,2)` minutes,
SD = `r (round(p.desc.duration$sd,2))`.

COMBINED: Across the entire sample, (n = `r a.desc.duration$n` ) participant response times
ranged from `r a.desc.duration$min` to `r a.desc.duration$max` minutes,
with a mean response time of `r round(a.desc.duration$mean,2)` minutes,
SD = `r (round(a.desc.duration$sd,2))`.

```{r demo-cleanup}
rm(df, df.p, df.t, p.desc.duration, t.desc.duration, desc.gender.p, desc.gender.t, p_participants, t_participants)
```




## SAMPLE Politics

```{r sample-politics}

#setup df
df <- df_b1_participants %>% select(PID, Sample, Study, D_politicalParty, D_politicsSocial, D_politicsFiscal)

## SCATTERPLOT #################
## Social X Fiscal Politics, colored by Sample
(p <- df %>% ggplot(aes(x = D_politicsSocial, y = D_politicsFiscal, color = Sample)) +
  geom_jitter(alpha = 0.5) + 
  scale_color_manual(values = my_palettes(name="samples", direction = "1")) + 
  facet_wrap(~Study) + 
  labs (title = "Political Leaning by Participant Study", x = "Social Values", y = "Fiscal Values") + theme_clean() + 
guides(
  x.sec = guide_axis_manual(
    position = "top",
    breaks = unit(c(0.2, 0.8), "npc"), 
    labels = expression("left-leaning", "right-leaning")),
  y.sec = guide_axis_manual(
    position = "right",angle=90,
    breaks = unit(c(0.2, 0.8), "npc"), 
    labels = expression("left-leaning", "right-leaning"))
  ) + theme_clean() + ggeasy::easy_remove_legend()
)

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = p, path="figs/level_block1", filename =paste0("B1_participant_politics.png"), units = c("in"), width = 10, height = 10,  bg='#ffffff'  )}


```



# MOCKUP (FIG 1) MAIN DESCRIPTIVES FIGURE (QUESTIONS + BLOCK 1 AGGREGATED)
## BLOCK 1 BY SAMPLE

### SD Questions
```{r block1_sds_by_sample, message=FALSE, warning = FALSE}


############## BLOCK 1 SDs by SAMPLE
 df <- df_b1_sds_long %>% select(1:8, QUESTION, Sample, value)  
 d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions),
          STUDY = fct_recode(Sample,
            Study_1  = "TUMBLR",
            Study_2 = "DATACOLLAR",
            Study_2 = "BLUECOLLAR",  
            Study_3 = "GENERAL")
          )%>% 
    group_by(QUESTION,STUDY,Sample) %>% 
    mutate(m=median(value)) %>% droplevels() ## calc median for printing on graph
  
  ## TODO ADD RUGS
(x <-
    ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill = Sample, color= Sample)) +
    geom_density_ridges(scale = 0.75, quantile_lines = TRUE, alpha = 0.25, panel_scaling = FALSE) + 
    scale_fill_manual(values = my_palettes(name="samples", direction = "1"))+
    scale_color_manual(values = my_palettes(name="samples", direction = "1"))+
    # scale_fill_manual(values = my_palettes(name="greys", direction = "1"))+ 
    facet_grid(.~STUDY) + 
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    # scale_x_continuous(limits = c(0,100))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs (title = "BLOCK 1 by Study & Sample", y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend() 
)
  

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_block1", filename =paste0("B1_SDS_by_sample_ridges.png"), units = c("in"), width = 10, height = 14,  bg='#ffffff'  )}
```


```{r block1_sds_study4fake, message=FALSE, warning = FALSE}
 
 ### FAKE STUDY 4
 (fake <-d %>% filter(STUDY=="Study_2") %>% 
    ggplot(aes(x = value, y = fct_rev(QUESTION), fill = Sample, color= Sample)) +
    geom_density_ridges(scale = 0.75, quantile_lines = TRUE, alpha = 0.25, panel_scaling = FALSE) + 
    scale_fill_manual(values = my_palettes(name="repeated", direction = "1"))+
    scale_color_manual(values = my_palettes(name="repeated", direction = "1"))+
    # scale_fill_manual(values = my_palettes(name="greys", direction = "1"))+ 
    facet_grid(.~STUDY) + 
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    # scale_x_continuous(limits = c(0,100))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs (title = "BLOCK 1 by Study & Sample", y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend() 
)

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_block1", filename =paste0("S4FAKE_by_sample_ridges.png"), units = c("in"), width = 10, height = 14,  bg='#ffffff'  )}
 
```
```{r block1_confidence, message=FALSE, warning = FALSE}


################## CONFIDENCE PLOTS 

## SETUP DATAFRAME 
df <- df_graphs %>% 
            filter(Assigned.Block==1) %>% 
            select(PID, Sample, STIMULUS,MAKER_CONF, AGE_CONF, GENDER_CONF, TOOL_CONF) %>% 
  pivot_longer(
    cols = c(MAKER_CONF, AGE_CONF, GENDER_CONF, TOOL_CONF),
    names_to = "QUESTION",
    values_to = "CONFIDENCE"
  ) %>% 
  mutate(
    QUESTION = factor(QUESTION, levels=c("MAKER_CONF","AGE_CONF","GENDER_CONF","TOOL_CONF"  ) )
  ) %>% 
  group_by(QUESTION, Sample) %>% 
  mutate(
    m=round(median(CONFIDENCE),0) #calc mean for showing in plots 
  )


## R
## CONFIDENCE BY SAMPLE FACET QUESTION (all stimuli, all Pps, by stdy)
R <- df %>% 
  ggplot(aes(x=CONFIDENCE, y=QUESTION, fill = Sample, color = Sample)) + #fill=fct_rev(QUESTION))) + 
    geom_density_ridges( aes(color = Sample), 
              ## ridge geometry
              scale = 0.65, alpha = 0.5, quantile_lines = TRUE,  panel_scaling = TRUE,
              ## rug geometry
              jittered_points = TRUE, rel_min_height = .01,
              point_shape = "|", point_size = 3,
              position = position_points_jitter(height = 0)) +
  facet_wrap(~Sample)+
    scale_x_continuous(limits = c(0,100))+
    scale_fill_manual(values = my_palettes(name="samples", direction = "1")) +
    scale_color_manual(values = my_palettes(name="samples", direction = "1")) +
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
  ## MEAN W/ GGDIST
    # stat_pointinterval(side = "bottom",  point_interval = "median_qi",
    #                    point_color="black", point_size=1, interval_alpha=0) +
  ## MEAN W/ STAT_SUMMARY
    # stat_summary(fun=median, geom="text", colour="black",  fontface = "bold", size=3,
    #             vjust=1.5, hjust = +0.5, aes( label=round(m, digits=0)))+
    # stat_summary(fun=mean, geom="point", size=1, color="blue", fill="blue") +
  theme_minimal() + 
  labs(title = "BLOCK 1 Confidence by Sample & Survey Question", y = "QUESTION", caption ="(point is mean)") 
###################################################
R  

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_block1", filename =paste0("B1_CONFIDENCE_by_sample_ridges.png"), units = c("in"), width = 10, height = 14,  bg='#ffffff'  )}
 
```
 
 
 
 
### Categorical Questions
 
```{r block1_categoricals, message=FALSE, warning = FALSE}



########################### BARPLOTS OF MAKER ID
 d <- df_b1_graphs %>% select(PID, Assigned.Block, Sample, STIMULUS, MAKER_ID, MAKER_AGE,MAKER_GENDER) %>%  mutate( STUDY = fct_recode(Sample,
            Study_1  = "TUMBLR",
            Study_2 = "DATACOLLAR",
            Study_2 = "BLUECOLLAR",  
            Study_3 = "GENERAL")
    ) 

## TUMBLR, GENERAL ONLY 
 d %>% filter(STUDY %in% c("Study_1", "Study_3")) %>%
  ggplot(aes(x=STUDY, fill=MAKER_ID)) + 
    geom_bar(position="fill") + 
    scale_fill_manual(values = my_palettes(name="reds", direction = "1"))+
   coord_flip()
 
 d %>% filter(STUDY %in% c("Study_2")) %>%
  ggplot(aes(x=Sample, fill=MAKER_ID)) + 
    geom_bar(position="fill") + 
    scale_fill_manual(values = my_palettes(name="reds", direction = "1"))+
   coord_flip()
 
 
 
 
 ########################### BARPLOTS OF MAKER AGE
 d <- df_b1_graphs %>% select(PID, Assigned.Block, Sample, STIMULUS, MAKER_ID, MAKER_AGE,MAKER_GENDER) %>%  mutate( STUDY = fct_recode(Sample,
            Study_1  = "TUMBLR",
            Study_2 = "DATACOLLAR",
            Study_2 = "BLUECOLLAR",  
            Study_3 = "GENERAL")
    ) 

## STUDY 1 STUDY 3
 d %>% filter(STUDY %in% c("Study_1", "Study_3")) %>%
  ggplot(aes(x=STUDY, fill=MAKER_AGE)) + 
    geom_bar(position="fill") + 
scale_fill_manual(values = my_palettes(name="lightblues", direction = "1")) +
   coord_flip()

 ## STUDY 2 
 d %>% filter(STUDY %in% c("Study_2")) %>%
  ggplot(aes(x=Sample, fill=MAKER_AGE)) + 
    geom_bar(position="fill") + 
    scale_fill_manual(values = my_palettes(name="lightblues", direction = "1")) +
   coord_flip()
 
 
 
########################### BARPLOTS OF MAKER GENDER
 
 d <- df_b1_graphs %>% select(PID, Assigned.Block, Sample, STIMULUS, MAKER_ID, MAKER_AGE,MAKER_GENDER) %>%  mutate( STUDY = fct_recode(Sample,
            Study_1  = "TUMBLR",
            Study_2 = "DATACOLLAR",
            Study_2 = "BLUECOLLAR",  
            Study_3 = "GENERAL")
    ) 

## TUMBLR, GENERAL ONLY 
 d %>% filter(STUDY %in% c("Study_1", "Study_3")) %>%
  ggplot(aes(x=STUDY, fill=MAKER_GENDER)) + 
    geom_bar(position="fill") + 
    scale_fill_manual(values = my_palettes(name="smallgreens", direction = "1")) +

   coord_flip()
 
 d %>% filter(STUDY %in% c("Study_2")) %>%
  ggplot(aes(x=Sample, fill=MAKER_GENDER)) + 
    geom_bar(position="fill") + 
        scale_fill_manual(values = my_palettes(name="smallgreens", direction = "1")) +
   coord_flip()
 
```
 
 
 
 
 













# MOCKUP (FIG 2) BY STIMULUS RESULTS

## BLOCK 1 STIMULUS (aggregate over samples)

##### density ridges
```{r plot_ridglines_sds_block1}
  

#DEFINE STIMULI
df <- df_graphs %>% filter(Assigned.Block==1) %>% droplevels()
stimuli <- levels(df$STIMULUS)


## LOOP THROUGH EACH STIMULUS IN LIST
i = 0

for (s in stimuli){
  i = i+1
  
  # setup titles 
  title <- ref_stimuli %>% filter(ID == s) %>% select(NAME)  ##TODO IF NOT WORK ref_stim_id
  title <- paste(s,"|",title)


#### DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, Sample, QUESTION, STIMULUS, value)  %>% filter(STIMULUS==s)
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions))%>% 
    group_by(QUESTION) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(x <-
    ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill=category)) +
    geom_density_ridges(
     ## ridge geometry
              scale = 0.65, alpha = 0.5, quantile_lines = TRUE,  panel_scaling = TRUE,
              ## rug geometry
              jittered_points = TRUE, rel_min_height = .01,
              point_shape = "|", point_size = 1, point_alpha=1,
              position = position_points_jitter(height = 0)) +
    
    scale_fill_manual(values = my_palettes(name="greys", direction = "1"))+
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    # scale_x_continuous(limits = c(0,100))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs (title = title, y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend()
)

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_block1", filename =paste0(s,"_by_sample_ridges_ALLSAMPLES.png"), units = c("in"), width = 10, height = 14,  bg='#ffffff'  )}


} ## END LOOP STIMULUI
```    






## BLOCK 1 STIMULUS BY SAMPLE (horizontal facet)
##### faceted density ridges
```{r plot_ridglines_sds_facet_b1}
  
#DEFINE STIMULI
df <- df_graphs %>% filter(Assigned.Block==1) %>% droplevels()
stimuli <- levels(df$STIMULUS)

## LOOP THROUGH EACH STIMULUS IN LIST
i = 0

for (s in stimuli){
  i = i+1
  
  # setup titles 
  title <- ref_stimuli %>% filter(ID == s) %>% select(NAME)  ##TODO IF NOT WORK ref_stim_id
  title <- paste(s,"|",title)


#### DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, Sample, QUESTION, STIMULUS, value)  %>% filter(STIMULUS==s)
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions))%>% 
    group_by(QUESTION, Sample) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(x <-
    ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill = Sample, color = Sample)) +
    # geom_density_ridges(scale = 0.75, quantile_lines = TRUE, alpha = 0.25, panel_scaling = TRUE) + 
    
    geom_density_ridges( 
              ## ridge geometry
              scale = 0.65, alpha = 0.25, quantile_lines = TRUE,  panel_scaling = TRUE,
              ## rug geometry
              jittered_points = TRUE, rel_min_height = .01,
              point_shape = "|", point_size = 1, point_alpha=1,
              position = position_points_jitter(height = 0)) +
    facet_grid(.~Sample)+
    scale_fill_manual(values = my_palettes(name="samples", direction = "1"))+
    scale_color_manual(values = my_palettes(name="samples", direction = "1"))+
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    # scale_x_continuous(limits = c(0,100))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs (title = title, y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend()
)

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_block1", filename =paste0(s,"_by_sample_ridges_FACET.png"), units = c("in"), width = 10, height = 14,  bg='#ffffff'  )}


} ## END LOOP STIMULUI
```    

##### stacked density ridges
```{r plot_ridglines_sds_block1}
  


#DEFINE STIMULI
df <- df_graphs %>% filter(Assigned.Block==1) %>% droplevels()
stimuli <- levels(df$STIMULUS)



## LOOP THROUGH EACH STIMULUS IN LIST
i = 0

for (s in stimuli){
  i = i+1
  
  # setup titles 
  title <- ref_stimuli %>% filter(ID == s) %>% select(NAME)  ##TODO IF NOT WORK ref_stim_id
  title <- paste(s,"|",title)


#### DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, Sample, QUESTION, STIMULUS, value)  %>% filter(STIMULUS==s)
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions))%>% 
    group_by(QUESTION,Sample) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(x <-
    ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill = Sample, color = Sample)) +
    geom_density_ridges(scale = 0.75, quantile_lines = FALSE, alpha = 0.25, panel_scaling = TRUE) + 
    scale_fill_manual(values = my_palettes(name="samples", direction = "1"))+
    scale_color_manual(values = my_palettes(name="samples", direction = "1"))+
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    # scale_x_continuous(limits = c(0,100))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs (title = title, y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend()
)

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_block1", filename =paste0(s,"_by_sample_ridges_STACK.png"), units = c("in"), width = 10, height = 14,  bg='#ffffff'  )}


} ## END LOOP STIMULUI
```    









## TODO BLOCK 1 STIMULUS BY SAMPLE (vertical facet) <-- arvind's suggestion





# PICKUP HERE TODO BY SAMPLE ANALYSIS

As we argue in our manuscript, we understand that an individual's
response to a visualization (both inferences about data, as well as any
other behaviours) will *vary* based on properties of: (1) the
visualization, (2) the data, (3) the individual, and (4) the situational
context. Thus, our survey is *not* designed to uncover *consistencies*
in behaviour, but rather, explore the nature of *variance* in behaviour
as a function of the individual and visualization.

(n = `r nrow(df_participants)` ) survey respondents answered questions
about some subset of the stimuli, (common stimulus B0-0 and 4 additional
images defined as a block), yielding (o = `r nrow(df_graphs)`)
stimulus-level observations.



##CONFIDENCE

```{r setup-full-sample}

#full stimulus-level data
df_full <- df_graphs %>% 
  mutate(
    STUDY = "" #dummy variable for univariate visualizations
  )
# %>%
#   mutate(MAKER_ID = fct_rev(MAKER_ID))

```

When asking participants to identify the type, age and gender of the
maker of a visualization, we also asked participants to indicate their
confidence in these choices.

**Across all participants and all stimuli, are these (categorical)
questions answered with the same degree of confidence?**

Here we examine both the central tendency (mean) and shape of the
distribution for each confidence variable.

```{r confidence-by-sample, message=FALSE}

df <- df_graphs

## SETUP DATAFRAME
df <- df_full %>% select(PID, Sample, STIMULUS,MAKER_CONF, AGE_CONF, GENDER_CONF, TOOL_CONF) %>% 
  pivot_longer(
    cols = c(MAKER_CONF, AGE_CONF, GENDER_CONF, TOOL_CONF),
    names_to = "QUESTION",
    values_to = "CONFIDENCE"
  ) %>% 
  mutate(
    QUESTION = factor(QUESTION, levels=c("MAKER_CONF","AGE_CONF","GENDER_CONF","TOOL_CONF"  ) )
  ) %>% 
  group_by(QUESTION, Sample) %>% 
  mutate(
    m=round(mean(CONFIDENCE),0) #calc mean for showing in plots 
  )

## B
## CONFIDENCE BY QUESTION FACET SAMPLE
## BOXPLOT W/ JITTER
B <-
  df %>% 
  ggplot(aes(x=QUESTION, y= CONFIDENCE)) + 
  geom_boxplot(width = 0.5) + 
  geom_jitter(alpha = 0.25, position=position_dodge2(width = 0.25)) + 
  ## MEAN
    stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size=3,
                 vjust=+0.5, hjust = -1.5, aes( label=round(m, digits=0)))+
    stat_summary(fun=mean, geom="point", size=2, color="blue", fill="blue") +
  scale_x_discrete(labels=c("MAKER","AGE","GENDER","TOOL"))+
  facet_grid(.~Sample) + 
  theme_minimal() + 
  labs(title = "Confidence by Question and Sample", caption = "(mean in blue)")
###################################################

## R
## CONFIDENCE BY SAMPLE FACET QUESTION (all stimuli, all Pps, by stdy)
R <- df %>% 
  ggplot(aes(x=CONFIDENCE, y=Sample, fill = Sample)) + #fill=fct_rev(QUESTION))) + 
    geom_density_ridges( aes(color = Sample), 
              ## ridge geometry
              scale = 0.65, alpha = 0.5, quantile_lines = TRUE,  panel_scaling = TRUE,
              ## rug geometry
              jittered_points = TRUE, rel_min_height = .01,
              point_shape = "|", point_size = 3,
              position = position_points_jitter(height = 0)) +
  facet_wrap(~QUESTION)+
    scale_x_continuous(limits = c(0,100))+
    
  ## MEAN W/ GGDIST
    stat_pointinterval(side = "bottom",  point_interval = "mean_qi",
                       point_color="black", point_size=1, interval_alpha=0) +
  ## MEAN W/ STAT_SUMMARY
    stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size=3,
                vjust=1.5, hjust = +0.5, aes( label=round(m, digits=0)))+
    # stat_summary(fun=mean, geom="point", size=1, color="blue", fill="blue") +
  theme_minimal() + 
  labs(title = "Confidence by Sample & Survey Question", y = "QUESTION", caption ="(point is mean)") 
###################################################
  
(B+R)

if(GRAPH_SAVE){ggsave(plot = (B+R), path="figs/level_samples", filename =paste0("CONFIDENCE_by_sample.png"), units = c("in"), width = 14, height = 8 ,  bg='#ffffff'  )}


```





## MAKER ID

Participants were asked:

**Who do you think is most likely responsible for having this image
created?\
***options:* (select one). The response is stored as `MAKER_ID`

-   business or corporation

-   journalist or news outlet

-   educational or academic institution

-   government or political organization

-   other organization

-   an individual]\

Participants were also asked: **Please rate your confidence in this
choice.** The response is stored as `MAKER_CONF` .

```{r maker-id-confidence}

df <- df_full

## D
## PROPORTIONAL BAR PLOT
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( MAKER_ID = fct_rev(MAKER_ID) )
S <-   ggbarstats( data = dx, x = MAKER_ID, y = Sample,
                   legend.title = "MAKER ID",
                   results.subtitle	 = FALSE) + 
    scale_fill_manual(values = my_palettes(name="reds", direction = "1")) +
    theme_minimal() +
    labs( title = "MAKERID by SAMPLE",  x = "SAMPLE", y="PROPORTION") + 
    theme(aspect.ratio = 1)
##############################


  
## H
## HALF EYE SLAB GGDIST
##############################
H <-  df %>% 
  group_by(MAKER_ID) %>% 
  mutate(count = n(), m = mean(MAKER_CONF)) %>% 
  ggplot(aes(y = MAKER_CONF, x = fct_rev(MAKER_ID), fill = fct_rev(MAKER_ID))) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=2, color="black", fill="black") +
  scale_fill_manual(values = my_palettes(name="reds", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) +
  labs(y="Maker ID Confidence", x="") +
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################


## HF
## HALF EYE SLAB GGDIST FACETED
##############################
HF <-  df %>% 
  group_by(MAKER_ID,Sample) %>% 
  mutate(count = n(), m = mean(MAKER_CONF)) %>% 
  ggplot(aes(y = MAKER_CONF, x = fct_rev(MAKER_ID), fill = fct_rev(MAKER_ID))) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  facet_wrap(~Sample)+
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=2, color="black", fill="black") +
  scale_fill_manual(values = my_palettes(name="reds", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) +
  labs(y="Maker ID Confidence", x="") +
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################
  

(p <- (S + H + HF) + plot_annotation(
  title = "Maker ID and Confidence by Sample",
  subtitle = "No salient differences in proportion of MAKERID by SAMPLE; no salient difs in CONFIDENCE by MAKERID",
  caption = ""
))

if(GRAPH_SAVE){ggsave(plot = p, path="figs/level_samples", filename =paste0("MAKER_by_sample.png"), units = c("in"), width = 20, height = 8 ,  bg='#ffffff'  )}


```



**INTERPRETATION** *The distribution of maker types is remarkably
consitent across levels of the `MAKER_ID` variable, with the exception
of 'organization' (with a smaller proportion). However, as 4 of the 6 categories are specific kinds
of organizations, this is not surprising. We believe this
distribution is likely a function of the diversity of stimuli we
selected. We will address this hypothesis in block-level analysis,
asking whether their is variance in the distribution of `MAKER_ID`
between stimuli. Notably, the confidence scores are similar (both in
mean and shape of distribution) regardless of the `MAKER_ID`, indicating
that in general, there is no particular maker identification for which
participants have less confidence.*

## MAKER AGE

Participants were asked: **Take a moment to imagine the person(s)
responsible for creating the image. What generation are they most likely
from?\
***options: (select one)* The response was saved as `MAKER_AGE`

-   *boomers (60+ years old)*

-   *Generation X (44-59 years old)*

-   *Millennials (28-43 years old)*

-   *Generation Z (12 - 27 years old]*

Participants were asked: **Please rate your confidence in this choice.**
The response is stored as `AGE_CONF` .

```{r maker-age-confidence}

#FILTER DATASET
df <- df_full


## D
## PROPORTIONAL BAR PLOT
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( MAKER_AGE = fct_rev(MAKER_AGE) )
S <-  ggbarstats( data = dx, x = MAKER_AGE, y = Sample,
                   legend.title = "MAKER AGE",
                   results.subtitle	 = FALSE) + 
    scale_fill_manual(values = my_palettes(name="lightblues", direction = "1")) +
    theme_minimal() +
    labs( title = "MAKER AGE by SAMPLE",  x = "", y="") + 
    theme(aspect.ratio = 1)
##############################


  
## HF
## HALF EYE SLAB GGDIST
##############################
HF <-df %>% 
  group_by(MAKER_AGE,Sample) %>% 
  mutate(count = n(), m = mean(AGE_CONF)) %>% 
  ggplot(aes(y = AGE_CONF, x = fct_rev(MAKER_AGE), fill = fct_rev(MAKER_AGE))) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  facet_wrap(~Sample)+
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="black", fill="black") +
  scale_fill_manual(values = my_palettes(name="lightblues", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="Maker AGE Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################

## H
## HALF EYE SLAB GGDIST
##############################
H <-
  df %>% 
  group_by(MAKER_AGE) %>% 
  mutate(count = n(), m = mean(AGE_CONF)) %>% 
  ggplot(aes(y = AGE_CONF, x = fct_rev(MAKER_AGE), fill = fct_rev(MAKER_AGE))) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="black", fill="black") +
  scale_fill_manual(values = my_palettes(name="lightblues", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="Maker AGE Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################
  

(p <- (S + H + HF) + plot_annotation(
  title = "Maker AGE and Confidence by Sample",
  # subtitle = "the categories of MAKER ID were chosen in similar proportion, 
  # and both the mean (in blue) and shape of distribution of confidence scores is similar across values of Maker ID",
  caption = ""
))

if(GRAPH_SAVE){ggsave(plot = p, path="figs/level_samples", filename =paste0("AGE_by_sample.png"), units = c("in"), width = 20, height = 8 ,  bg='#ffffff'  )}


```


**INTERPRETATION** *The distribution of maker ages is distributed as we
would expect if participants are answering the question with some sense
of the maker's occupation in mind, thus answering with generations that
are mostly likely of working age (gen X, millennial). As with
`MAKER_ID`, confidence scores are similar (both in mean and shape of
distribution) across all levels of `MAKER_AGE`, indicating that in
general, there is no `MAKER_AGE` for which participants have less
confidence.*

## MAKER GENDER

Participants were asked: **Take a moment to imagine the person(s)
responsible for creating the image. What gender do they most likely
identify with?\
***options: [female / male / other ] (select one).* Responses were
stored as `MAKER_GENDER.`

Participants were asked: **Please rate your confidence in this choice.**
The response is stored as `GENDER_CONF` .


```{r maker-gender-confidence}

#FILTER DATASET
df <- df_full


## D
## PROPORTIONAL BAR PLOT
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( MAKER_GENDER = fct_rev(MAKER_GENDER) )
S <-  ggbarstats( data = dx, x = MAKER_GENDER, y = Sample,
                   legend.title = "MAKER GENDER",
                   results.subtitle	 = FALSE) + 
    scale_fill_manual(values = my_palettes(name="smallgreens", direction = "1")) +
    theme_minimal() +
    labs( title = "MAKER GENDER by SAMPLE",  x = "", y="") + 
    theme(aspect.ratio = 1)
##############################


  
## HF
## HALF EYE SLAB GGDIST
##############################
HF <-df %>% 
  group_by(MAKER_GENDER,Sample) %>% 
  mutate(count = n(), m = mean(GENDER_CONF)) %>% 
  ggplot(aes(y = GENDER_CONF, x = fct_rev(MAKER_GENDER), fill = fct_rev(MAKER_GENDER))) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  facet_wrap(~Sample)+
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="black", fill="black") +
  scale_fill_manual(values = my_palettes(name="smallgreens", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="MAKER GENDER Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################

## H
## HALF EYE SLAB GGDIST
##############################
H <-
  df %>% 
  group_by(MAKER_GENDER) %>% 
  mutate(count = n(), m = mean(GENDER_CONF)) %>% 
  ggplot(aes(y = GENDER_CONF, x = fct_rev(MAKER_GENDER), fill = fct_rev(MAKER_GENDER))) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="black", fill="black") +
  scale_fill_manual(values = my_palettes(name="smallgreens", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="MAKER GENDER Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################
  

(p <- (S + H + HF) + plot_annotation(
  title = "MAKER GENDER and Confidence by Sample",
  # subtitle = "the categories of MAKER ID were chosen in similar proportion, 
  # and both the mean (in blue) and shape of distribution of confidence scores is similar across values of Maker ID",
  caption = ""
))

if(GRAPH_SAVE){ggsave(plot = p, path="figs/level_samples", filename =paste0("GENDER_by_sample.png"), units = c("in"), width = 20, height = 8 ,  bg='#ffffff'  )}


```


**INTERPRETATION:** *The distribution of maker genders is not evenly
distributed between men and women as we might expect. We suspect it is
most likely that the 'male' category serves as a default value for the
maker gender, in the absence of any particular feature of stimulus that
viewers interpret as strongly feminine. This hypothesis is grounded in
the free response data, where respondents tend to explicitly describe
gender in the presence of a design feature consistent with modern
western stereotypes (such us pink indicating feminine, or aggressive
indicating masculine).  We also see substantially lower confidence in attributions of a third category of gender. 
*

## TOOL ID

Participants were asked: **What tools do you think were most likely used
to create this image?\
***options: (select all that apply).* The response was saved as variable
`TOOL_ID` (multi-select)

-   basic graphic design software (e.g. Canva, or similar)

-   advanced graphic design software (e.g. Adobe Illustrator, Figma, or
    similar)

-   data visualization software (e.g. Tableau, PowerBI, or similar)

-   general purpose software (e.g. MS Word/Excel, Google Sheets, or
    similar)

-   programming language (e.g. R, python, javascript, or similar)

Participants were asked: **Please rate your confidence in this choice.**
The response is stored as `TOOL_CONF` .

```{r tool-confidence}

#FILTER DATASET
df <- df_tools


## D
## PROPORTIONAL BAR PLOT
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
S <-  ggbarstats( data = df, x = TOOL_ID, y = Sample,
                   legend.title = "TOOL ID",
                   results.subtitle	 = FALSE) + 
    scale_fill_manual(values = my_palettes(name="tools", direction = "1")) +
    theme_minimal() +
    labs( title = "TOOL by SAMPLE",  x = "", y="") + 
    theme(aspect.ratio = 1)
##############################


  
## HF
## HALF EYE SLAB GGDIST
##############################
HF <-df %>% 
  group_by(TOOL_ID,Sample) %>% 
  mutate(count = n(), m = mean(TOOL_CONF)) %>% 
  ggplot(aes(y = TOOL_CONF, x = TOOL_ID, fill = TOOL_ID)) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  facet_wrap(~Sample)+
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="black", fill="black") +
  scale_fill_manual(values = my_palettes(name="tools", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="TOOL ID Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################

## H
## HALF EYE SLAB GGDIST
##############################
H <-
  df %>% 
  group_by(TOOL_ID) %>% 
  mutate(count = n(), m = mean(TOOL_CONF)) %>% 
  ggplot(aes(y = TOOL_CONF, x = TOOL_ID, fill = TOOL_ID)) + 
  stat_halfeye(scale=0.55, density="bounded", point_interval = "mean_qi", normalize= "all") +
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="black",  fontface = "bold", size = 2,
               vjust=2.5, hjust = .5, aes( label=round(m, digits=0)))+
  stat_summary(fun=mean, geom="point", shape=20, size=3, color="black", fill="black") +
  scale_fill_manual(values = my_palettes(name="tools", direction = "-1"), guide = guide_legend(reverse = TRUE)) +
  geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
            size = 3, nudge_x=0.35) + 
  labs(y="TOOL ID Confidence", x="") + 
  theme_minimal() + 
  easy_remove_legend()+
  coord_flip() 
##############################
  

(p <- (S + H + HF) + plot_annotation(
  title = "TOOL ID and Confidence by Sample",
  # subtitle = "the categories of MAKER ID were chosen in similar proportion, 
  # and both the mean (in blue) and shape of distribution of confidence scores is similar across values of Maker ID",
  caption = ""
))

if(GRAPH_SAVE){ggsave(plot = p, path="figs/level_samples", filename =paste0("TOOLS_by_sample.png"), units = c("in"), width = 20, height = 8 ,  bg='#ffffff'  )}


```

**INTERPRETATION** *We had no expectations with respect to the
distribution of values in tool identification, but note that are roughly
even across categories (exception of 'unknown' and 'programming'), and
the confidence scores are similar.*

## ENCOUNTER CHOICE

The first question each participant saw in each stimulus block was: **As
you're scrolling through your feed, you see this image. What would you
do?**

options: keep scrolling, pause and look at the image. (select one) The
response was saved as variable `ENCOUNTER`

```{r}
## B
## ENCOUNTER  BY STIMULUS
## GGSTATSPLOT

(p <- df_full %>% 
  ggbarstats(  
            x = ENCOUNTER, y = Sample,
            legend.title = "ENCOUNTER",
            results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="encounter", direction = "-1"))+
    theme_minimal() + 
    labs( title = "ENCOUNTER Choice ", subtitle = "", x = "")
)

# (p <- df_full %>% 
#   ggbarstats(  
#             x = ENCOUNTER, y = STUDY,
#             legend.title = "ENCOUNTER",
#             results.subtitle = FALSE) + 
#     scale_fill_manual(values = my_palettes(name="encounter", direction = "-1"))+
#     theme_minimal() + 
#     labs( title = "ENCOUNTER Choice ", subtitle = "", x = "")
# )

if(GRAPH_SAVE){ggsave(plot = p, path="figs/level_samples", filename =paste0("ENCOUNTER_by_sample.png"), units = c("in"), width = 14, height = 8 ,  bg='#ffffff'  )}
```

**INTERPRETATION** *TUMBLR participants were twice as likely to ENGAGE rather than SCROLL, while both of the Prolific samples, 
in 10% more trials (participant + stimulus), participants indicated they would likely engage with the image* *rather
than scroll past it.*

## ACTION CHOICE

The last question participants were asked in each stimulus block was:
**Imagine you encounter the following image while scrolling. Which of
the following are you most likely to do?**

options: (select all that apply). The response was saved as variable
`CHART_ACTION`

-   post a comment

-   share/repost

-   share/repost WITH comment

-   look up more information about the topic or source

-   unfollow/block the source

-   NOTHING—just keep scrolling

```{r action-choice-by-sample}

#FILTER DATASET
df <- df_actions

### FULL ACTION
## D
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( CHART_ACTION = fct_rev(CHART_ACTION) )
S <-   ggbarstats( data = dx, x = CHART_ACTION, y = Sample,
                   legend.title = "ACTION",
                   results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="actions", direction = "1")) +
    theme_minimal() +
    labs( title = "CHART ACTION by SAMPLE",  x = "", y="", caption="no data for data/blue collar") + 
    theme(aspect.ratio = 1)
##############################

if(GRAPH_SAVE){ggsave(plot = S, path="figs/level_samples", filename =paste0("ACTION_by_sample.png"), units = c("in"), width = 14, height = 8 ,  bg='#ffffff'  )}
S

### 4 ACTION
## D
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( CHART_ACTION4 = fct_rev(CHART_ACTION4) )
S <-   ggbarstats( data = dx, x = CHART_ACTION4, y = Sample,
                   legend.title = "ACTION",
                   results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="actions4", direction = "1")) +
    theme_minimal() +
    labs( title = "CHART ACTION [4] by SAMPLE",  x = "", y="", caption="no data for data/blue collar") + 
    theme(aspect.ratio = 1)
##############################

if(GRAPH_SAVE){ggsave(plot = S, path="figs/level_samples", filename =paste0("ACTION4_by_sample.png"), units = c("in"), width = 14, height = 8 ,  bg='#ffffff'  )}
S

### 3 ACTION
## D
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( CHART_ACTION3 = fct_rev(CHART_ACTION3) )
S <-   ggbarstats( data = dx, x = CHART_ACTION3, y = Sample,
                   legend.title = "ACTION",
                   results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="actions3", direction = "1")) +
    theme_minimal() +
    labs( title = "CHART ACTION [3] by SAMPLE",  x = "", y="",caption="no data for data/blue collar") + 
    theme(aspect.ratio = 1)
##############################

if(GRAPH_SAVE){ggsave(plot = S, path="figs/level_samples", filename =paste0("ACTION3_by_sample.png"), units = c("in"), width = 14, height = 8 ,  bg='#ffffff'  )}
S

### 2 ACTION
## D
## GGSTATSPLOT
##############################
#hack for consistent ordering of ggstats bar plot
dx <- df %>% mutate( CHART_ACTION2 = fct_rev(CHART_ACTION2) )
S <-   ggbarstats( data = dx, x = CHART_ACTION2, y = Sample,
                   legend.title = "ACTION",
                   results.subtitle = FALSE) + 
    scale_fill_manual(values = my_palettes(name="actions2", direction = "1")) +
    theme_minimal() +
    labs( title = "CHART ACTION [2] by SAMPLE",  x = "", y="",caption="no data for data/blue collar") + 
    theme(aspect.ratio = 1)
##############################

if(GRAPH_SAVE){ggsave(plot = S, path="figs/level_samples", filename =paste0("ACTION2_by_sample.png"), units = c("in"), width = 14, height = 8 ,  bg='#ffffff'  )}
S
```


## SEMANTIC DIFFERENTIALS

Participants were also asked to rate certain characteristics of the
chart, or its maker, along a **semantic differential scale**,
implemented in Qualtrics as a continuous slider ranging from 0 -\> 100
with biploar adjectives at the end of each scale. The slider defaulted
to the center point (50), and the interface displayed the numeric value
of the slider position as a tooltip while the element had focus. Note
that on both touch and mouse devices participants could interact with
the survey element as a slider (i.e. click and and drag, or touch and
drag) *or* as a visual analogue scale (i.e. click or tap on position
along the scale).

### FULL SCALES

*The SD scores visualized here are in the same form as the participants'
response scale (slider from 0-100).*

#### BLOCK ONE COMBINED 

##### boxplot



```{r plot_boxplot_sds_by_sample, fig.width=10, fig.height=14}

  #### LIST OF BLOXPLOTS + JITTER #############################################################################

  # setup dataframe 
  df <- df_graphs 
  
  #subset data cols 
  cols <- df %>% select( all_of(ref_sd_questions))
  plots <- as.list(lapply(colnames(cols), plot_sd, data = df, type ="S", mean=TRUE, facet = TRUE, facet_by = "Sample", boxplot=TRUE, labels=ref_labels))
  
  #aggregate q plots into one for stimulus 
  plot_master_questions <- plots[[1]] / plots[[2]] / plots[[3]] / plots[[4]] / plots[[5]] / plots[[6]] / plots[[7]] /
   plots[[8]] /plots[[9]] /plots[[10]] /plots[[11]] + 
   plot_annotation(
     title = "BLOCK 1 STIMULI by SAMPLE",
     subtitle ="TUMBLR is RED; DATACOLLAR is GREEN, BLUECOLLAR is BLUE", caption = "(point is mean)"
   )
  
if(GRAPH_SAVE == TRUE){  
  ggsave(plot = plot_master_questions, path="figs/level_samples", filename =paste0("SD_BLOCK1_stimuli_by_sample","_box.png"), units = c("in"), width = 10, height = 14  )
}

print(plot_master_questions)
  
```  


  
##### ggdist halfeye
```{r plot_halfeye_sds_by_sample}

  #### GGDIST PLOT#############################################################################
  
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, QUESTION, STIMULUS_CATEGORY, value) 
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
               category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions)) %>% 
    group_by(QUESTION,Distribution) %>% 
    mutate(m=median(value)) ## calc median for printing on graph

  # GGDIST HALFEYE (raincloud doesn't work b/c long tails)
  (g <- d %>%
      ggplot(aes(y = fct_rev(QUESTION), x = value, fill=category)) +
    stat_halfeye(scale=0.8, density="bounded", point_interval = "median_qi", normalize="xy") +
    facet_wrap(~Sample) + 
      ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    scale_color_manual(values = my_palettes(name="greys", direction = "1"))+
    scale_fill_manual(values = my_palettes(name="greys", direction = "1"))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left), title = ""),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
  cowplot::draw_text(text = ref_sd_questions, x = 90, y= ref_sd_questions,size = 8, vjust=-2) +
  labs (title = "BLOCK1 by SAMPLE", y = "", caption = "(point is median)") +
  theme_minimal() + easy_remove_legend()
)

  if(GRAPH_SAVE == TRUE){ 
  ggsave(plot = g, path="figs/level_samples", filename =paste0("SD_BLOCK1_stimuli_by_sample","_ggdist.png"), units = c("in"), width = 10, height = 14  )
  }
  

```


##### faceted density ridges
```{r plot_ridglines_sds_by_sample}
  
#### DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, QUESTION, value)  
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions))%>% 
    group_by(QUESTION,Sample) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(x <-
    ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill = category)) +
    geom_density_ridges(scale = 0.75, quantile_lines = TRUE, alpha = 0.75, panel_scaling = TRUE) + 
    # scale_fill_manual(values = my_palettes(name="amy_gradient", direction = "1"))+ 
    scale_fill_manual(values = my_palettes(name="greys", direction = "1"))+ 
    facet_wrap(~Sample) + 
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    # scale_x_continuous(limits = c(0,100))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs (title = "BLOCK 1 by Sample", y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend()
)

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_samples", filename =paste0("SD_BLOCK1_stimuli_by_sample","_ridges.png"), units = c("in"), width = 10, height = 14  )
}


```    
##### stacked density ridges
```{r plot_stacked_ridglines_sds_by_sample}
  
#### DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, QUESTION, value)  
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions))%>% 
    group_by(QUESTION,Sample) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(x <-
    ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill = Sample, color = Sample)) +
    geom_density_ridges(scale = 0.75, quantile_lines = FALSE, alpha = 0.25, panel_scaling = TRUE) + 
    # scale_fill_manual(values = my_palettes(name="amy_gradient", direction = "1"))+ 
    # scale_fill_manual(values = my_palettes(name="greys", direction = "1"))+ 
    # facet_wrap(~Sample) + 
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=1) +
    scale_x_continuous(limits = c(0,100))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs (title = "BLOCK 1 by Sample", y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend()
)

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_samples", filename =paste0("SD_BLOCK1_stimuli_by_sample","_stacked_ridges.png"), units = c("in"), width = 10, height = 14  )
}


``` 

  
##### wraped ridgelines

```{r plot_faceted_ridglines_sds_by_sample}

#### DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, QUESTION, value)  
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions))%>% 
    group_by(QUESTION,Sample) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(x <-
    ggplot(d, aes(x = value, y = Sample, fill = Sample)) +
    geom_density_ridges(scale = 0.75, quantile_lines = TRUE, alpha = 0.75, panel_scaling = TRUE) + 
    facet_wrap(~QUESTION) + 
    ## MEDIAN
    # stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
    #             vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    # stat_summary(fun=median, geom="point", size=2) +
    # # scale_x_continuous(limits = c(0,100))+
    ## CAN'T GET GUIDE TO WORK
    # guides(
      # y = guide_axis_manual(labels = c(d$QUESTION,"b","c")),
      # y = guide_axis_manual(labels = ref_labels[d$QUESTION,2]),
      # y.sec = guide_axis_manual(labels = rev(ref_labels$right))
      # y = guide_axis_manual(labels = rev(ref_labels$left)),
      # y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    # ) +
    # labs (title = "BLOCK 1 by Sample", y = "", caption = "(point is median)") +
    # cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend()
)
  
  if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_samples", filename =paste0("SD_BLOCK1_stimuli_by_sample","_wrapped_ridges.png"), units = c("in"), width = 10, height = 14  )
}

```


#### BY STIMULUS and SAMPLE

##### boxplots
```{r plot_boxplot_sds, fig.width=10, fig.height=14}


#DEFINE STIMULI
df <- df_graphs
stimuli <- levels(df$STIMULUS)


## LOOP THROUGH EACH STIMULUS IN LIST
i = 0

for (s in stimuli){
  i = i+1
  
  # setup dataframe 
  title <- ref_stimuli %>% filter(ID == s) %>% select(NAME)  ##TODO IF NOT WORK ref_stim_id
  title <- paste(s,"|",title)
  df <- df_graphs %>% filter(STIMULUS== s)

  
  #### BOXPLOT PLOT
  #subset data cols 
  cols <- df %>% select( all_of(ref_sd_questions))
  plots <- as.list(lapply(colnames(cols), plot_sd, data = df, type ="S", mean=TRUE, facet = TRUE, facet_by = 'Sample', boxplot=TRUE, labels = ref_labels))

  #aggregate q plots into one for stimulus 
  x <- plots[[1]] / plots[[2]] / plots[[3]] / plots[[4]] / plots[[5]] / plots[[6]] / plots[[7]] /
   plots[[8]] /plots[[9]] /plots[[10]] /plots[[11]] + 
   plot_annotation(
     title = title,
     subtitle ="", caption = "(point is mean)")
   
  
 
if(GRAPH_SAVE){
  ggsave(plot = x, path="figs/level_samples", filename =paste0(s,"_by_sample_box.png"), units = c("in"), width = 10, height = 14  ,  bg='#ffffff'  )}

  
} ## END LOOP 
```

##### ggdist halfeye
```{r plot_halfeye_sds}


#DEFINE STIMULI
df <- df_graphs
stimuli <- levels(df$STIMULUS)


## LOOP THROUGH EACH STIMULUS IN LIST
i = 0

for (s in stimuli){
  i = i+1
  
  # setup titles 
  title <- ref_stimuli %>% filter(ID == s) %>% select(NAME)  ##TODO IF NOT WORK ref_stim_id
  title <- paste(s,"|",title)

  # setup dataframe
  df <- df_sd_questions_long %>% select(1:8, Sample, STIMULUS, QUESTION, STIMULUS_CATEGORY, value) %>% filter(STIMULUS == s)
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
               category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions)) %>% 
    group_by(QUESTION) %>% 
    mutate(m=median(value)) ## calc median for printing on graph

  # GGDIST HALFEYE (raincloud doesn't work b/c long tails)
  (g <- d %>%
      ggplot(aes(y = fct_rev(QUESTION), x = value, fill=Sample, color=Sample)) +
      stat_halfeye(scale=0.8, density="bounded", point_interval = "median_qi", normalize="xy", alpha=0.25) +
    
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    # scale_color_manual(values = my_palettes(name="greys", direction = "1"))+
    # scale_fill_manual(values = my_palettes(name="greys", direction = "1"))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left), title = ""),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
  cowplot::draw_text(text = ref_sd_questions, x = 90, y= ref_sd_questions,size = 8, vjust=-2) +
  labs (title = title, y = "", caption = "(point is median)") +
  theme_minimal() + easy_remove_legend()
)

  if(GRAPH_SAVE == TRUE){ 
  ggsave(plot = g, path="figs/level_samples", filename =paste0(s,"_by_sample_ggdist.png"), units = c("in"), width = 10, height = 14,  bg='#ffffff'  )}
  

  
} ## END LOOP 
```

##### density ridges
```{r plot_ridglines_sds}
  


#DEFINE STIMULI
df <- df_graphs
stimuli <- levels(df$STIMULUS)



## LOOP THROUGH EACH STIMULUS IN LIST
i = 0

for (s in stimuli){
  i = i+1
  
  # setup titles 
  title <- ref_stimuli %>% filter(ID == s) %>% select(NAME)  ##TODO IF NOT WORK ref_stim_id
  title <- paste(s,"|",title)


#### DENSITY RIDGES#############################################################################
  # setup dataframe 
  df <- df_sd_questions_long %>% select(1:8, Sample, QUESTION, STIMULUS, value)  %>% filter(STIMULUS==s)
  d <- left_join( x = df, y = ref_labels, 
                  by = c("QUESTION" = "ref_sd_questions")) %>% 
        mutate(
          category=factor(category, levels=c("COMPETENCY","MAKER","CHART")),
          QUESTION = factor(QUESTION, levels=ref_sd_questions))%>% 
    group_by(QUESTION) %>% 
    mutate(m=median(value)) ## calc median for printing on graph
  
  
(x <-
    ggplot(d, aes(x = value, y = fct_rev(QUESTION), fill = Sample, color = Sample)) +
    geom_density_ridges(scale = 0.75, quantile_lines = FALSE, alpha = 0.25, panel_scaling = TRUE) + 
    # scale_fill_manual(values = my_palettes(name="amy_gradient", direction = "1"))+ 
    # scale_fill_manual(values = my_palettes(name="greys", direction = "1"))+ 
    ## MEDIAN
    stat_summary(fun=median, geom="text", fontface = "bold", size= 2.2,
                vjust=+2, hjust = 0.50, aes(label=round(m, digits=0)))+
    stat_summary(fun=median, geom="point", size=2) +
    # scale_x_continuous(limits = c(0,100))+
    guides(
      y = guide_axis_manual(labels = rev(ref_labels$left)),
      y.sec = guide_axis_manual(labels = rev(ref_labels$right))
    ) +
    labs (title = title, y = "", caption = "(point is median)") +
    cowplot::draw_text(text = ref_sd_questions, x = 100, y= ref_sd_questions,size = 8, vjust=-2, position=position_nudge(y=-.20))  + ##raw
    # cowplot::draw_text(text = ref_sd_questions, x = -4, y= ref_sd_questions,size = 10, vjust=-2) + ##z-score
    theme_minimal() + easy_remove_legend()
)

if(GRAPH_SAVE == TRUE) {
    ggsave(plot = x, path="figs/level_samples", filename =paste0(s,"_by_sample_ridges.png"), units = c("in"), width = 10, height = 14,  bg='#ffffff'  )}


} ## END LOOP STIMULUI
```    













## MODELS

### Predicting ATTITUDE
```{r test}

#set data
df <- df_sd_questions_long

# predict value by QUESTION + STIMULUS + Sample +  random PID

## EMPTY MODEL (random intercept on participant)
m0 <- lmer (data = df, value ~ (1|PID))
summary(m0)
performance(m0)
plot_model(m0, type = "re")


m1 <- lmer (data = df, value ~ QUESTION + (1|PID))
summary(m1)
performance(m1)
car::Anova(m1, type=2)
plot_model(m1, type="eff", terms = "QUESTION")

m2 <- lmer (data = df, value ~ QUESTION + Sample + (1|PID))
summary(m2)
performance(m2)
car::Anova(m2, type=2)
plot_model(m2, type="pred", terms = c("QUESTION", "Sample")) 


m3 <- lmer (data = df, value ~ QUESTION * Sample + (1|PID))
summary(m3)
performance(m3)
car::Anova(m3, type=3)
plot_model(m3, type="int")




## singular fit
## m <- lmer(data = df, value ~ QUESTION + STIMULUS + Sample + 1|PID)


```








### Predicting TRUST 

What predicts TRUST? Recent work in psychology suggests that beauty predicts trust. However, from our free response data, we think that some aesthetically pleasing images are interpreted as persuasive and thus less trustworthy.  On this basis, we predict that there will be a significant interaction between BEAUTY and INTENT


#### exploratory visualizations
```{r hypo-trust-beauty_intent-}

df <- df_graphs %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  # filter(STIMULUS != "B0-0") %>%
  select(PID, STIMULUS, STIMULUS_CATEGORY, BLOCK, ENCOUNTER, CHART_TRUST, CHART_BEAUTY, CHART_INTENT, MAKER_TRUST, MAKER_DATA, MAKER_ID) %>% 
  mutate(
    
    ## (only used if not filtering out B0-0)
    ## RECODE #recode b00 graph as category D [bc it fits in that category]
    # STIMULUS_CATEGORY = fct_recode(STIMULUS_CATEGORY, D="F") 
  ) %>% droplevels()


df %>% ggplot(aes(x=CHART_BEAUTY, y=CHART_TRUST, color = CHART_INTENT)) +
  geom_point() + 
  stat_smooth(method = "lm", formula = y ~ x, geom = "smooth") + 
  facet_wrap(~MAKER_ID)+
  labs(title = "CHART TRUST BY BEAUTY & INTENT") + 
  theme_minimal()
  
df %>% ggplot(aes(x=CHART_INTENT, y=CHART_TRUST, color = CHART_BEAUTY)) +
  geom_point() + 
  facet_wrap(~MAKER_ID)+
  stat_smooth(method = "lm", formula = y ~ x, geom = "smooth") + 
  labs(title = "CHART TRUST BY INTENT & BEAUTY")+ 
  theme_minimal()

df %>% ggplot(aes(x=MAKER_DATA, y=CHART_TRUST, color = CHART_BEAUTY)) +
  geom_point() + 
  facet_wrap(~MAKER_ID)+
  stat_smooth(method = "lm", formula = y ~ x, geom = "smooth") + 
  labs(title = "CHART TRUST BY INTENT & BEAUTY")+ 
  theme_minimal()

df %>% ggplot(aes(x=MAKER_ID, y=CHART_TRUST, color = CHART_BEAUTY)) +
  # geom_point() + 
  geom_boxplot() + geom_point(position=position_jitter(width = 0.2))+
  # stat_smooth(method = "lm", formula = y ~ x, geom = "smooth") + 
  labs(title = "CHART TRUST BY INTENT & BEAUTY")+ 
  theme_minimal()


```





#### MODEL

Is BEAUTY or INTENT a better predictor of TRUST?  Here we fit a series of linear mixed effects models, predicting `CHART_TRUST` by `CHART_BEAUTY` and `CHART_INTENT` 



##### SETUP DATA
```{r hypo-trust_beauty_intent-fit}

df <- df_graphs %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  # filter(STIMULUS != "B0-0") %>% 
  select(PID, STIMULUS,STIMULUS_CATEGORY, MAKER_ID, MAKER_TRUST, CHART_TRUST, CHART_BEAUTY, CHART_INTENT, MAKER_DATA) %>% 
  mutate(
    TRUST_Z = datawizard::standardise(CHART_TRUST),
    BEAUTY_Z = datawizard::standardise(CHART_BEAUTY),
    INTENT_Z = datawizard::standardise(CHART_INTENT),
    DATA_Z = datawizard::standardise(MAKER_DATA),
    r_MAKER_DATA = datawizard::reverse(MAKER_DATA), # reverse b/c 0 = professional, 100=layperson
    r_DATA_Z = datawizard::standardise(r_MAKER_DATA)
  ) %>% 
  droplevels()

################## BUILD MODELS #################

# # RANDOM INTERCEPT SUBJECT
# mm.rP <- lmer(CHART_TRUST ~ (1|PID), data = df)
# print("random effect only")
# summary(mm.rP)
```



##### TRUST ~ empty model

```{r}
################## TRUST ~ (1|PID) #################
f.0 <-  "TRUST ~  (1|PID)"
print("TRUSTS ~  (1|PID)")
mm.0 <- lmer(TRUST_Z ~  (1|PID), data = df)
# car::Anova(mm.0, type=2)
summary(mm.0)
performance(mm.0)
## REPORT 
# report(mm.B)

## PLOT 
plot_model(mm.0, type = "re") + 
  labs(subtitle = f.0) + theme_minimal()

```

##### TRUST ~ BEAUTY 
```{r}
################## TRUST ~ BEAUTY #################
f.B <-  "TRUST ~ BEAUTY + (1|PID)"
print("TRUSTS ~ BEAUTY + (1|PID)")
mm.B <- lmer(TRUST_Z ~ BEAUTY_Z + (1|PID), data = df)
car::Anova(mm.B, type=2)
summary(mm.B)
performance(mm.B)
## REPORT 
# report(mm.B)

## PLOT 
plot_model(mm.B, type = "eff", terms = "BEAUTY_Z") + 
  labs(subtitle = f.B) + theme_minimal()


## IN PAPER

```


##### TRUST ~ INTENT 
```{r}

################## TRUST ~ INTEN #################
f.I <-  "TRUST ~ INTENT + (1|PID)"
mm.I <- lmer(TRUST_Z ~ INTENT_Z + (1|PID), data = df)
car::Anova(mm.I, type=2)
summary(mm.I)
performance(mm.I)

## REPORT 
# report(mm.I)

## PLOT 
plot_model(mm.I, type = "pred", terms = "INTENT_Z") + 
  labs(subtitle = f.I) + theme_minimal()

## IN PAPER
# tab_model(mm.I)

```



##### TRUST ~ DATA !!COMPETING!!
```{r}


################## TRUST ~ DATA #################
f.D <-  "TRUST ~ DATA + (1|PID)"
mm.D <- lmer(TRUST_Z ~ DATA_Z + (1|PID), data = df)
car::Anova(mm.D, type=2)
summary(mm.D)
performance(mm.D)

## REPORT 
# report(mm.I)

## PLOT 
plot_model(mm.D, type = "pred", terms = "DATA_Z") + 
  labs(subtitle = f.D) + theme_minimal()


```
##### TRUST ~ MAKER_ID
```{r}


################## TRUST ~ MAKER #################
f.M <-  "TRUST ~ MAKER + (1|PID)"
mm.M <- lmer(TRUST_Z ~ MAKER_ID + (1|PID), data = df)
car::Anova(mm.M, type=2)
summary(mm.M)
performance(mm.M)
## REPORT
# report(mm.M)

## PLOT
plot_model(mm.M, type = "pred", terms = "MAKER_ID") +
  labs(subtitle = f.M) + theme_minimal()

```



##### compare 
```{r}

compare_performance(mm.B, mm.I, mm.D, rank = TRUE)
anova(mm.B, mm.I, mm.D)

```



##### TRUST ~ BEAUTY X INTENT 
```{r}


## ADD IXN EFFECT 
################## TRUST ~ BEAUTY X INTENT  #################
f.BxI <-  "TRUST ~ BEAUTY X INTENT + (1|PID)"
print("TRUST ~ BEAUTY X INTENT + (1|PID)")
mm.BxI <- lmer(TRUST_Z ~ INTENT_Z * BEAUTY_Z +  (1|PID), data = df, REML=FALSE)
compare_performance(mm.BxI, mm.B, mm.I, rank = TRUE)
anova(mm.BxI, mm.B, mm.I)
# anova(mm.BxM, mm.BM)
print ("ADDING interaction BEAUTY * INTENT IMPROVES MODEL FIT  ")
car::Anova(mm.BxI, type=3)
summary(mm.BxI)


## REPORT 
# report(mm.BxI)

## PLOT 

## IN THE PAPER 
plot_model(mm.BxI, type = "int", terms = c("BEAUTY_Z", "INTENT_Z"), mdrt.values = "all") + 
  labs(subtitle = f.BxI) + theme_minimal()

plot_model(mm.BxI, type = "pred", terms = c("BEAUTY_Z", "INTENT_Z")) + 
  labs(subtitle = f.BxI) + theme_minimal()

# means <- estimate_means(mm.BxI, at=c("BEAUTY_Z", "INTENT_Z"))
# contrasts <- estimate_contrasts(mm.BxI, c( "INTENT_Z", "BEAUTY_Z"), method="pairwise")
# plot(means, contrasts)  #+  facet_wrap(~intent_Z) + labs(subtitle = f.BxI) + theme_minimal()


### IN THE PAPER 
tab_model(mm.BxI)

m <- mm.BxI
```






!! TODO PICKUP HERE !! 
##### BEST TRUST ~ BEAUTY X INTENT + DATA *** BEST MODEL *** 
```{r}


################## TRUST ~ BEAUTY X INTENT  #################
f.BxID <-  "TRUST ~ BEAUTY X INTENT+DATA + (1|PID)"
print("TRUST ~ BEAUTY X INTENT + DATA + (1|PID)")
mm.BxID <- lmer(TRUST_Z ~ INTENT_Z * BEAUTY_Z + DATA_Z + (1|PID), data = df, REML=FALSE)
compare_performance(mm.BxI, mm.BxID, rank = TRUE)
anova(mm.BxI, mm.BxID)
# anova(mm.BxM, mm.BM)
car::Anova(mm.BxID, type=3)
summary(mm.BxID)


## REPORT 
# report(mm.BxI)

## PLOT 

## IN THE PAPER 
plot_model(mm.BxID, type = "eff", terms = c("BEAUTY_Z", "DATA_Z", "INTENT_Z"), mdrt.values = "all") + 
  labs(subtitle = f.BxID) + theme_minimal()

plot_model(mm.BxID, type = "pred", terms = c("INTENT_Z", "BEAUTY_Z", "DATA_Z")) + 
  labs(subtitle = f.BxID) + theme_minimal()

## IN THE PAPER 
tab_model(mm.BxID)

# means <- estimate_means(mm.BxI, at=c("BEAUTY_Z", "INTENT_Z"))
# contrasts <- estimate_contrasts(mm.BxI, c( "INTENT_Z", "BEAUTY_Z"), method="pairwise")
# plot(means, contrasts)  #+  facet_wrap(~intent_Z) + labs(subtitle = f.BxI) + theme_minimal()

tab_model(mm.BxID)
anova(mm.B, mm.I, mm.D, mm.BxID)




p <- plot_model(mm.BxID, type = "pred", terms = c("INTENT_Z", "BEAUTY_Z", "DATA_Z")) + 
  labs(subtitle = f.BxID) + theme_minimal()



 ggsave(p, scale =1, filename = "figs/PAPER/mmBxID.svg", width = 14, height = 6, dpi = 320, limitsize = FALSE)
 t <- tab_model(mm.BxID)
# ggsave(t, scale =1, filename = "figs/PAPER/mmBxID_table.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)

# first save table to html file
tab_model(mm.BxID, file = "figs/PAPER/mmBxID_table.html")

# then take this html file and make .png file
webshot("figs/PAPER/mmBxID_table.html", "figs/PAPER/mmBxID_table.svg")
```
### not using 

##### TRUST ~ BEAUTY X MAKER_ID
```{r}

# 
# ## ADD IXN EFFECT 
# ################## TRUST ~ BEAUTY X MAKER_ID  #################
# f.BxM <-  "TRUST ~ BEAUTY X MAKER_ID + (1|PID)"
# print("TRUST ~ BEAUTY X MAKER_ID + (1|PID)")
# mm.BxM <- lmer(TRUST_Z ~ MAKER_ID * BEAUTY_Z +  (1|PID), data = df)
# compare_performance(mm.BxM, mm.BM, rank = TRUE)
# test_lrt(mm.BxM, mm.BM)
# # anova(mm.BxM, mm.BM)
# print ("ADDING interaction MAKER ID IMPROVES MODEL FIT ")
# car::Anova(mm.BxM, type=3)
# summary(mm.BxM)
# 
# 
# ## REPORT 
# report(mm.BxM)
# 
# ## PLOT 
# plot_model(mm.BxM, type = "int", terms = c("BEAUTY_Z", "MAKER_ID"), mdrt.values = "all") + 
#   labs(subtitle = f.BxM) + theme_minimal()
# 
# plot_model(mm.BXM, type = "pred", terms = c("BEAUTY_Z", "MAKER_ID")) + 
#   labs(subtitle = f.BM) + theme_minimal()
# 
# means <- estimate_means(mm.BM, at=c("BEAUTY_Z", "MAKER_ID"))
# contrasts <- estimate_contrasts(mm.BM, c( "MAKER_ID"),method="pairwise")
# plot(contrasts, means) + facet_wrap("MAKER_ID") + labs(subtitle = f.BxM) + theme_minimal()

```








##### TRUST ~ BEAUTY X MAKER_ID
```{r}

# 
# ## ADD IXN EFFECT 
# ################## TRUST ~ BEAUTY X MAKER_ID  #################
# f.BxM <-  "TRUST ~ BEAUTY X MAKER_ID + (1|PID)"
# print("TRUST ~ BEAUTY X MAKER_ID + (1|PID)")
# mm.BxM <- lmer(TRUST_Z ~ MAKER_ID * BEAUTY_Z +  (1|PID), data = df)
# compare_performance(mm.BxM, mm.BM, rank = TRUE)
# test_lrt(mm.BxM, mm.BM)
# # anova(mm.BxM, mm.BM)
# print ("ADDING interaction MAKER ID IMPROVES MODEL FIT ")
# car::Anova(mm.BxM, type=3)
# summary(mm.BxM)
# 
# 
# ## REPORT 
# report(mm.BxM)
# 
# ## PLOT 
# plot_model(mm.BxM, type = "int", terms = c("BEAUTY_Z", "MAKER_ID"), mdrt.values = "all") + 
#   labs(subtitle = f.BxM) + theme_minimal()
# 
# plot_model(mm.BXM, type = "pred", terms = c("BEAUTY_Z", "MAKER_ID")) + 
#   labs(subtitle = f.BM) + theme_minimal()
# 
# means <- estimate_means(mm.BM, at=c("BEAUTY_Z", "MAKER_ID"))
# contrasts <- estimate_contrasts(mm.BM, c( "MAKER_ID"),method="pairwise")
# plot(contrasts, means) + facet_wrap("MAKER_ID") + labs(subtitle = f.BxM) + theme_minimal()

```

##### TRUST ~ BEAUTY X MAKER_ID X INTENT
```{r}


# ## ADD IXN EFFECT 
# ################## TRUST ~ BEAUTY X MAKER_ID  #################
# f.BxMxI <-  "TRUST ~ BEAUTY X MAKER_ID X INTENT+ (1|PID)"
# print("TRUST ~ BEAUTY X MAKER_ID X INTENT + (1|PID)")
# mm.BxMxI <- lmer(TRUST_Z ~ MAKER_ID * BEAUTY_Z* INTENT_Z +  (1|PID), data = df)
# compare_performance(mm.BxMxI, mm.BxM, rank = TRUE)
# test_lrt(mm.BxMxI, mm.BxM)
# # anova(mm.BxM, mm.BM)
# car::Anova(mm.BxMxI, type=3)
# summary(mm.BxMxI)
# 
# 
# ## REPORT 
# report(mm.BxMxI)
# 
# ## PLOT 
# plot_model(mm.BxMxI, type = "int", mdrt.values = "all")
# 
# plot_model(mm.BxMxI, type = "pred", terms = c("BEAUTY_Z", "MAKER_ID", "INTENT_Z"))  
#   
# # 
# # means <- estimate_means(mm.BM, at=c("BEAUTY_Z", "MAKER_ID"))
# # contrasts <- estimate_contrasts(mm.BM, c( "MAKER_ID"),method="pairwise")
# # plot(contrasts, means) + facet_wrap("MAKER_ID") + labs(subtitle = f.BxM) + theme_minimal()
# 
# compare_performance(mm.BxI, mm.BxMxI, rank = TRUE)
# anova(mm.BxI, mm.BxMxI)
# 
# 
# 
# 
# 




```




```{r}
## INTENT MAIN EFFECT 
# SUBJECT INTERCEPT | FIXED BEAUTY 
print("TRUSTS ~ INTENT + (1|PID)")
mm.IrP <- lmer(CHART_TRUST ~ CHART_INTENT + (1|PID), data = df)
# :: TEST fixed factor 
compare_performance(mm.rP, mm.BrP, mm.IrP, rank = TRUE)
paste("AIC with INTENT is lower than BEAUTY model?", AIC(logLik(mm.BrP)) > AIC(logLik(mm.IrP)) )
anova(mm.BrP, mm.IrP, test = "Chi") #same as anova(m0, m1, test = "Chi")
print("A model with INTENT IS a better fit than model with BEAUTY")
car::Anova(mm.IrP, type=2)
print("BEAUTY IS a significant predictor in the model")
summary(mm.IrP)


## BEAUTY AND INTENT MAIN EFFECTS 
# SUBJECT INTERCEPT | BEAUTY + INTENT
print("TRUST ~ INTENT + BEAUTY + (1|PID)")
mm.IBrP <- lmer(CHART_TRUST ~ CHART_INTENT + CHART_BEAUTY + (1|PID), data = df)
# :: TEST fixed factor 
compare_performance(mm.rP, mm.BrP, mm.IrP, mm.IBrP, rank = TRUE)
##anova instead of LRT b/c models are not nested 
anova(mm.IrP,mm.IBrP, mm.BrP) #same as anova(m0, m1, test = "Chi")
test_lrt(mm.IrP, mm.IBrP)
test_lrt(mm.BrP, mm.IBrP)
paste("A model with a linear combination of BEAUTY and INTENT predicting TRUST is a significantly better fit than either fixed effect alone.")
car::Anova(mm.IBrP, type = 2)
summary(mm.IBrP)
print("CATEGORY is a significant predictor in this model, but BLOCK is not")


## BEAUTY INTENT INTERACTION
# SUBJECT INTERCEPT | INTENT * BEAUTY 
print("TRUST ~ INTENT * BEAUTY + (1|PID)")
mm.IBXrP <- lmer(CHART_TRUST ~ CHART_INTENT * CHART_BEAUTY + (1|PID), 
                data = df) 
               # control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               # optCtrl=list(maxfun=2e5)))
# :: TEST fixed factor 
compare_performance(mm.IBXrP, mm.IBrP, mm.IrP, mm.BrP, rank = TRUE)
##anova instead of LRT b/c models are not nested 
anova(mm.IBXrP, mm.IBrP)
test_lrt(mm.IBrP, mm.IBXrP, verbose = TRUE) #same as anova(m0, m1, test = "Chi")
paste("A model with an interaction is significantly better fit")
car::Anova(mm.IBXrP, type = 3)
print("In this model, both the main effects and interaction are significant")




#############VERSION WITH ZSCORED VARS 
## BEAUTY INTENT INTERACTION
# SUBJECT INTERCEPT | INTENT * BEAUTY 
print("TRUST ~ INTENT * BEAUTY + (1|PID)")
mm.ZIBXrP <- lmer(TRUST_Z ~ INTENT_Z * BEAUTY_Z + (1|PID), 
                data = df) 
               # control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               # optCtrl=list(maxfun=2e5)))
# :: TEST fixed factor 
compare_performance(mm.IBXrP, mm.ZIBXrP, rank = TRUE) ## should be the same
##anova instead of LRT b/c models are not nested 
car::Anova(mm.ZIBXrP, type = 3)
summary(mm.ZIBXrP)



## SET BEST 
m_best <- mm.ZIBXrP
f <- "(ZSCORED) TRUST ~ INTENT * BEAUTY"


############ PARTIAL CORRELATION SANITY CHECK 

# print("PARTIAL CORRELATION WITH PID AS RANDOM EFFECT")
# #CALCULATE partial correlations with PID as random effect
# ## (this isolates correlation pairwise factoring out other variables)
# c <- df %>% correlation(partial=TRUE,multilevel = TRUE)
# (s <- c %>% summary(redundant = FALSE ))


# ###### VIS WITH CORRELATION PACKAGE
# #SEE [correlation] PLOT
# g <- plot(s, show_data = "point",   show_text = "label",
#      stars=TRUE, show_legend=FALSE,
#      show_statistic = FALSE, show_ci = FALSE) + 
#      theme_minimal()+
#      labs(title = "All Stimuli | Correlation Matrix — SD Questions", 
#           subtitle="(partial correlation; pearson method; Holm p-value adjustment; participant as random effect)")
#      # text = list(fontface = "italic")
# g
# ggsave(g, scale =1, filename = "figs/level_aggregated/models/partial_correlation_mmIBXrP.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)





```






#### model describe

```{r hypo-trust_beauty_intent}

############ DESCRIBE FINAL MODEL ###########
summary(m_best)
report(m_best)


######### PRINT COEFFICIENTS 
# print("COEFFICIENT ESTIMATES — LOG ODDS")
# tidy(m_best)
# print("COEFFICIENT ESTIMATES — ODDS RATIOS")
# tidy(m_best, exponentiate=TRUE)

``` 


#### check rescaling
```{r}
# 
# ## rescale all vars to be -1 to 0 to 1
# df <- df_graphs %>%
#   ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
#   # filter(STIMULUS != "B0-0") %>% 
#   select(PID, CHART_TRUST, CHART_BEAUTY, CHART_INTENT, MAKER_ID, STIMULUS_CATEGORY, MAKER_DATA) %>% 
#   mutate(
#     TRUST_Z = datawizard::standardise(CHART_TRUST),
#     BEAUTY_Z = datawizard::standardise(CHART_BEAUTY),
#     INTENT_Z = datawizard::standardise(CHART_INTENT),
#     r_MAKER_DATA = datawizard::reverse(MAKER_DATA), # reverse b/c 0 = professional, 100=layperson
#     r_DATA_Z = datawizard::standardise(r_MAKER_DATA),
#     
#     TRUST_S = datawizard::rescale(CHART_TRUST, to=c(-1,1)),
#     BEAUTY_S = datawizard::rescale(CHART_BEAUTY, to=c(-1,1)),
#     INTENT_S = datawizard::rescale(CHART_INTENT, to=c(-1,1)),
#     DATA_S = datawizard::rescale(MAKER_DATA, to=c(-1,1)),
#     r_DATA_S = datawizard::reverse(DATA_S), # reverse b/c 0 = professional, 100=layperson
#     
#     TRUST_SZ = datawizard::standardise(TRUST_S, to=c(-1,1))
#     
#   ) %>% 
#   droplevels()
# 
# 
# 
# gf_histogram(df, ~CHART_TRUST)
# gf_histogram(df, ~TRUST_S)
# gf_histogram(df, ~TRUST_Z)
# gf_histogram(df, ~TRUST_SZ)
#              



```

#### model vis
```{r hypo-category-encounter-modelvis}
# 
# ############ VISUALIZE MODEL COEFFICIENTS 
# #SJPLOT | MODEL | ODDS RATIO
# #library(sjPlot)
# plot_model(mm.ZIBXrP, type = "est",
#            vline.color = "red", 
#            show.intercept = TRUE, 
#            show.values = TRUE) + theme_minimal()  + 
#   labs(title = "Model Coefficients",
#        subtitle = "")
# 
# 
# 
# ############ VISUALIZE MODEL PREDICTIONS
# #SJPLOT | MODEL | PROBABILITIES
# plot_model(m_best, type = "int", mdrt.values = "meansd") + theme_minimal()
# 
# 
# plot_model(m_best, type="emm", 
#            terms = c("BEAUTY_Z"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for BEAUTY")
# 
# plot_model(m_best, type="emm", 
#            terms = c("INTENT_Z"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for INTENT")
# 
# plot_model(m_best, type="emm", 
#            terms = c("BEAUTY_Z","INTENT_Z"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for INTERACTION")
# 
# plot_model(m_best, type="emm", 
#            terms = c("INTENT_Z", "BEAUTY_Z"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for INTERACTION")
# 
# 
# 
# ## CONTINUOUS INTERACTIONS 
# result <- estimate_expectation(m_best, data = "grid")
# plot(result) + theme_minimal()
# 
# result <- estimate_expectation(m_alt, data = "grid")
# plot(result) + theme_minimal()
# 
# 
# result <- estimate_prediction(m_best, data = "grid")
# plot(result) + theme_minimal()
# 
# 
# 
# 
# 
# ##EXAMPLES NOT WORKING EITHER
# # slopes <- estimate_slopes(m_best, trend = "INTENT_Z", by = "BEAUTY_Z")
# # plot(slopes)
# 
# 
# # model <- lm(mpg ~ hp * wt, data = mtcars)
# # slopes <- estimate_slopes(model, trend = "hp", by = "wt")
# # plot(slopes)
# 
# 
# 
# 
# ## TRY ADDING MAKER ID 
# 
# mm.beauty <- lmer(TRUST_Z ~ BEAUTY_Z + (1|PID), data = df)
# mm.intent <- lmer(TRUST_Z ~ INTENT_Z + (1|PID), data = df)
# mm.makerbeauty <- lmer(TRUST_Z ~ BEAUTY_Z*MAKER_ID + (1|PID), data = df)
# 
# 
# 
# plot_model(mm.beauty, type = "eff", terms = "BEAUTY_Z")
# plot_model(mm.intent, type = "eff", terms = "INTENT_Z")
# 
# plot_model(mm.makerbeauty, type = "int")
# 
# 
# 
#   plot_model(m_best, type = "int")
# 
# 
# plot_model(m_best, type = "int", mdrt.values = "all")
# 
# 
# mm.icat = update(m_best, .~. *MAKER_ID)
# compare_performance(m_best, mm.icat, mm.idata, rank = TRUE)
# car::Anova(mm.icat, type=3)
# plot_model(mm.icat, type = "int", mdrt.values = "meansd")
# 
# mm.idata = update(m_best, .~. *r_DATA_Z)
# compare_performance(m_best, mm.icat, mm.idata, rank = TRUE)
# car::Anova(mm.idata, type=3)
# plot_model(mm.idata, type = "int", mdrt.values = "meansd")
# 
# 
# 
# # plot_model(mm.ZIBXrP, type = "est",vline.color = "red", show.intercept = TRUE, show.values = TRUE) + theme_minimal()  + 
# #   labs(title = "Model Coefficients", subtitle = "")
# # plot_model(mm.cat, type = "est",vline.color = "red", show.intercept = TRUE, show.values = TRUE) + theme_minimal()  + 
# #   labs(title = "Model Coefficients", subtitle = "")
# # plot_model(mm.cat, type = "emm", terms=c("MAKER_ID" , "INTENT_Z","BEAUTY_Z"))
# 
# 
# 
# 


```














## !! HERE STOPPED UPDATING HERE !! CORRELATIONS

### FULL SCALE


```{r, correlation-matrices}


df <- df_graphs %>% 
  mutate(
    M_DESIGN =  datawizard::standardize(MAKER_DESIGN)  , 
    M_DATA =  datawizard::standardize(MAKER_DATA)  , 
    M_POLITIC =  datawizard::standardize(MAKER_POLITIC)  , 
    M_ARGUE =  datawizard::standardize(MAKER_ARGUE)  ,
    M_SELF =  datawizard::standardize(MAKER_SELF)  , 
    M_ALIGN =  datawizard::standardize(MAKER_ALIGN)  , 
    M_TRUST =  datawizard::standardize(MAKER_TRUST)  , 
    C_TRUST =  datawizard::standardize(CHART_TRUST)  , 
    C_INTENT =  datawizard::standardize(CHART_INTENT)  , 
    C_LIKE =  datawizard::standardize(CHART_LIKE)  , 
    C_BEAUTY =  datawizard::standardize(CHART_BEAUTY)  
  ) %>% select(
    M_DESIGN, M_DATA, M_POLITIC, M_ARGUE, M_SELF, M_ALIGN, M_TRUST, C_TRUST, C_INTENT, C_LIKE, C_BEAUTY,  PID
  )


######################### FULL CORRELATION #########################
print("FULL CORRELATION WITH RANDOM EFFECT")
## CALCULATE full correlations with random effects
c <- df %>%  correlation(partial=FALSE, include_factors=FALSE, multilevel=TRUE)
# cor_sort(c) ## for the tiles one
(s <- c %>% summary(redundant = FALSE))


###### VIS WITH CORRELATION PACKAGE
#SEE [correlation] PLOT
g <- plot(s,    show_text = "label",
          show_data = "point",
     stars=TRUE, show_legend=FALSE,
     show_statistic = FALSE, show_ci = FALSE) + 
     theme_minimal()+
     labs(title = "All Stimuli | Correlation Matrix — SD Questions", 
          subtitle="(full correlation; pearson method; Holm p-value adjustment; PID random effect)") + theme_minimal()
     # text = list(fontface = "italic")
g
ggsave(g, scale =1, filename = "figs/level_aggregated/heatmaps/full_correlation_all_POINTS.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)


######################### FULL CORRELATION #########################
print("PARTIAL CORRELATION WITH PID AS RANDOM EFFECT")
#CALCULATE partial correlations with PID as random effect
## (this isolates correlation pairwise factoring out other variables)
c <- df %>% correlation(partial=TRUE,multilevel = TRUE)
# cor_sort(c) ## for the tiles one
(s <- c %>% summary(redundant = FALSE ))


###### VIS WITH CORRELATION PACKAGE
#SEE [correlation] PLOT
g <- plot(s, show_text = "label",
          show_data = "point",
     stars=TRUE, show_legend=FALSE,
     show_statistic = FALSE, show_ci = FALSE) + 
     theme_minimal()+
     labs(title = "All Stimuli | Correlation Matrix — SD Questions", 
          subtitle="(partial correlation; pearson method; Holm p-value adjustment; participant as random effect)")
     # text = list(fontface = "italic")
g
ggsave(g, scale =1, filename = "figs/level_aggregated/heatmaps/partial_correlation_all_POINTS.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)


###### VIS WITH CORRPLOT <- -- customizable but can't save to file ARGH
# 
# ## GET THE MATRIX
# m <- as.matrix(c)
# 
#
# ## JUST CIRCLES
# corrplot(m, method = 'circle', type = 'lower',
#          order = 'original', diag = FALSE, addCoef.col = "#7A7A7A",
#          tl.col = "black")
##############################################################################

```

These plots depict the PARTIAL CORRELATION pairwise between variables
(partial correlation factors out influence of other variables), with
participant ID as a random effect. The resulting values are pearson
moment-correlation coefficients ranging of -1 (direct negative) to +1
direct positive correlation. These correlations are calculated on the
full scale semantic differential questions (i.e. with the 0 - 100 range,
where 1 and 100 are end points and 50 is the central point)

#### node-link diagram
```{r}
###################PLOT GAUSSIAN GRAPH MODEL
## get only significant correlations
m <- c # the correlation matrix
## default from easystats
# plot(m)


## 1 SIMPLY NODE NAMES
m <- as_tibble(c) %>% 
  mutate(
    Parameter1 = str_replace_all(Parameter1, "MAKER_", "M_"),
    Parameter1 = str_replace_all(Parameter1, "CHART_", "C_"),
    Parameter2 = str_replace_all(Parameter2, "MAKER_", "M_"),
    Parameter2 = str_replace_all(Parameter2, "CHART_", "C_")
  ) 

## 2 SHOW ONLY SIGNIFICANT CORRELATIONS
m <- m %>% 
  filter(p <= 0.05)

## 3 FORMAT AS GRAPH
g <- as_tbl_graph(m)


### Gaussian Graphical Models (GGMs)
# Bhushan et al., 2019
# https://www.frontiersin.org/journals/psychology/articles/10.3389/fpsyg.2019.01050/full

f <- 
  ggraph(g, layout = 'stress') +
  # ggraph(g, layout = 'linear', circular = TRUE) +
  geom_edge_link(aes(colour =r, 
                     edge_width = r,
                     label = round(r,2))) +
  geom_node_point( size = 5) + 
  geom_node_label(size = 3,
                 # vjust = +1,
                 # hjust = 0.5,
                 repel = TRUE,
                  aes(label = name))  + 
    scale_edge_color_gradient2(low = "red",
    mid = "white",
    high = "blue",
    midpoint = 0,
    space = "Lab",
    # na.value = "grey50",
    guide = "edge_colourbar",
    aesthetics = "edge_colour") + 
    theme_graph() + labs(title = "All Stimuli | Significant Partial Correlations (full SD scale)")
  

f 
  


```


### ABSOLUTE VALUES

```{r, correlation-matrices—abs}


df <- df_graphs_abs %>% 
  mutate(
    M_DESIGN =  datawizard::standardize(MAKER_DESIGN)  , 
    M_DATA =  datawizard::standardize(MAKER_DATA)  , 
    M_POLITIC =  datawizard::standardize(MAKER_POLITIC)  , 
    M_ARGUE =  datawizard::standardize(MAKER_ARGUE)  ,
    M_SELF =  datawizard::standardize(MAKER_SELF)  , 
    M_ALIGN =  datawizard::standardize(MAKER_ALIGN)  , 
    M_TRUST =  datawizard::standardize(MAKER_TRUST)  , 
    C_TRUST =  datawizard::standardize(CHART_TRUST)  , 
    C_INTENT =  datawizard::standardize(CHART_INTENT)  , 
    C_LIKE =  datawizard::standardize(CHART_LIKE)  , 
    C_BEAUTY =  datawizard::standardize(CHART_BEAUTY)  
  ) %>% select(
    M_DESIGN, M_DATA, M_POLITIC, M_ARGUE, M_SELF, M_ALIGN, M_TRUST, C_TRUST, C_INTENT, C_LIKE, C_BEAUTY,  PID
  )


######################### FULL CORRELATION #########################

print("FULL CORRELATION NO RANDOM EFFECT")
## CALCULATE full correlations with no random effects
c <- df %>%  correlation(partial=FALSE, multilevel=TRUE)
# cor_sort(c) ## for the tiles one
(s <- c %>% summary(redundant = FALSE))

g <- plot(s,    show_text = "label",
          # show_data = "point",
     stars=TRUE, show_legend=FALSE,
     show_statistic = FALSE, show_ci = FALSE) + 
     theme_minimal()+
     labs(title = "All Stimuli | Correlation Matrix — SD Questions — ABSOLUTE VALUES", 
          subtitle="(full correlation; pearson method; Holm p-value adjustment; PID random effect)") + theme_minimal()
     # text = list(fontface = "italic")
g
ggsave(g, scale =1, filename = "figs/level_aggregated/heatmaps/ABS_full_correlation_all_POINTS.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)



######################### PARTIAL CORRELATION #########################


print("PARTIAL CORRELATION WITH PID AS RANDOM EFFECT")
#CALCULATE partial correlations with PID as random effect
## (this isolates correlation pairwise factoring out other variables)
c <- df %>% correlation(partial=TRUE, multilevel = TRUE)
# cor_sort(c) ## for the tiles one
(s <- c %>% summary(redundant = FALSE ))


###### VIS WITH CORRELATION PACKAGE
#SEE [correlation] PLOT
g <- plot(s, show_text = "label",
          # show_data = "point",
     stars=TRUE, show_legend=FALSE,
     show_statistic = FALSE, show_ci = FALSE) + 
     theme_minimal()+
     labs(title = "All Stimuli | Correlation Matrix — SD Questions — ABSOLUTE VALUES", 
          subtitle="(partial correlation; pearson method; Holm p-value adjustment; participant as random effect)")
     # text = list(fontface = "italic")
g
ggsave(g, scale =1, filename = "figs/level_aggregated/heatmaps/ABS_partial_correlation_all_POINTS.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)

#PLOT GAUSSIAN GRAPH MODEL
# plot(c)


###### VIS WITH CORRPLOT <- -- customizable but can't save to file ARGH

## GET THE MATRIX
m <- as.matrix(c)


## JUST CIRCLES
corrplot(m, method = 'circle', type = 'lower',
         order = 'original', diag = FALSE, addCoef.col = "#7A7A7A",
         tl.col = "black")

```

**INTERPRETATION** *These plots depict the PARTIAL CORRELATION pairwise between variables
(partial correlation factors out influence of other variables), with
participant ID as a random effect. The resulting values are pearson
moment-correlation coefficients ranging of -1 (direct negative) to +1
direct positive correlation. These correlations are calculated on the
ABSOLUTE VALUE of the semantic differential questions (i.e. with the
full scale folded in half, such that 50 now becomes 0, and the extrememe
values (0, 100) become 50). The absolute value scale allows us to
collapse for weak (near zero) vs. strong (near 50) signal in each
variable.*

### correlation matrices — by category levels

*Here we explore the distribution of each SD variable (e.g. MAKER TRUST)
by the different values of each categorical variable (e.g. MAKER ID).
Patterns of interest are noted, which we explore further in the section
**exploratory questions**.*

##### MAKER ID X SD

```{r, maker_id-sds}


df <- df_graphs %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                           PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                           MAKER_ID, MAKER_AGE, MAKER_GENDER)

## CORRELATION MATRIX SPLIT BY MAKER ID  
(x <-   ggscatmat(df, columns = 1:11, color = "MAKER_ID", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="reds", direction = "1"), name = "",  guide = guide_legend(reverse = FALSE)) +   
    theme_minimal()
)
if(GRAPH_SAVE){
ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("maker_id_corr_sd.png"), units = c("in"), width = 14, height = 10 )
}

x


```

**Interesting patterns to explore further**

-   When participants identify the maker as an INDIVIDUAL, the following
    variables show a different pattern than the other identifications:
    MAKER_DESIGN, MAKER_DATA, CHART INTENT
-   interesting bimodal distribution on CHART INTENT for most
    identifications, except individuals and organizations

##### MAKER ID X SD (abs)

```{r, maker_id-sds-abs}


df <- df_graphs_abs %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                           PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                           MAKER_ID, MAKER_AGE, MAKER_GENDER)

## CORRELATION MATRIX SPLIT BY MAKER ID  
(x <-   ggscatmat(df, columns = 1:11, color = "MAKER_ID", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="reds", direction = "1"), name = "",  guide = guide_legend(reverse = FALSE)) +   
    theme_minimal())
    
if(GRAPH_SAVE){
ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("maker_id_corr_abs.png"), units = c("in"), width = 14, height = 10 )
}
x

```

##### MAKER AGE X SD

```{r, maker_age-sds}


  df <- df_graphs %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                           PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                           MAKER_ID, MAKER_AGE, MAKER_GENDER)
  
  ## CORRELATION MATRIX SPLIT BY MAKER AGE  
  (x <-   ggscatmat(df, columns = 1:11, color = "MAKER_AGE", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="lightblues", direction = "1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
    theme_minimal())
    
if(GRAPH_SAVE){    
  ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("maker_age_corr_sd.png"), units = c("in"), width = 14, height = 10 )
}
x  

```

**Interesting patterns to explore further**

-   maker_design, chart_like, chart_beauty for BOOMER vs. others
-   maker_data for gen Z vs others

##### MAKER AGE X SD (abs)

```{r, maker_age-sds-abs}

  
  df <- df_graphs_abs %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                           PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                           MAKER_ID, MAKER_AGE, MAKER_GENDER)

  ## CORRELATION MATRIX SPLIT BY MAKER AGE  
  (x <-   ggscatmat(df, columns = 1:11, color = "MAKER_AGE", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="lightblues", direction = "1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
    theme_minimal())
    
if(GRAPH_SAVE){
  ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("maker_age_corr_abs.png"), units = c("in"), width = 14, height = 10 )
}
x

```

##### MAKER GENDER X SD

```{r, maker_gender-sds}

  
  df <- df_graphs %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                           PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                           MAKER_ID, MAKER_AGE, MAKER_GENDER)
  
  ## CORRELATION MATRIX SPLIT BY MAKER GENDER  
  (x <-   ggscatmat(df, columns = 1:11, color = "MAKER_GENDER", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="smallgreens", direction = "1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
    theme_minimal() )
    
    if(GRAPH_SAVE){
  ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("maker_gender_corr_sd.png"), units = c("in"), width = 14, height = 10 )
  }
  x

```

**Interesting patterns to explore further** - maker-data for FEMALE

##### MAKER GENDER X SD (abs)

```{r, maker_gender-sds-abs}

  
  df <- df_graphs_abs %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                           PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                           MAKER_ID, MAKER_AGE, MAKER_GENDER)

  
  ## CORRELATION MATRIX SPLIT BY MAKER GENDER  
  (x <-   ggscatmat(df, columns = 1:11, color = "MAKER_GENDER", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="smallgreens", direction = "1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
    theme_minimal() )

if(GRAPH_SAVE){
  ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("maker_gender_corr_abs.png"), units = c("in"), width = 14, height = 10 )
}
  x

```

##### TOOL ID X SD

```{r, tool-id-sds}

  
df <- df_tools %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                    PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                    TOOL_ID) 
  
  ## CORRELATION MATRIX SPLIT BY TOOL ID
 (x <-  ggscatmat(df, columns = 1:11, color = "TOOL_ID", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="tools", direction = "1"), name = "",  guide = guide_legend(reverse = TRUE)) +
    theme_minimal() )
  
  if(GRAPH_SAVE){
  ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("tool_id_corr_sd.png"), units = c("in"), width = 14, height = 10 )
  }    
  x

```

**Interesting patterns to explore further** - maker data for
design-basic, interesting pattern - look closer at chart beauty -
interesting pattern across values on chart intent

##### ENCOUNTER X SD

```{r, encounter-sds}

  

df <- df_graphs %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                    PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                    ENCOUNTER) %>% 
    mutate(ENCOUNTER = fct_rev(ENCOUNTER))

## CORRELATION MATRIX SPLIT BY ENCOUNTER
(x <-   ggscatmat(df, columns = 1:11, color = "ENCOUNTER", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="encounter", direction = "1"))+
    theme_minimal())
if(GRAPH_SAVE){
  ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("encounter_corr_sd.png"), units = c("in"), width = 14, height = 10 )
}
  x
  
  
```

**Interesting patterns to explore further** — no difference at ALL in
maker data - interesting! - chart beauty very diff - chart intent
intersting bimodal

##### ENCOUNTER X SD (abs)

```{r, encounter-sds-abs}

  

df <- df_graphs_abs %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                    PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                    ENCOUNTER) %>% 
    mutate(ENCOUNTER = fct_rev(ENCOUNTER))

## CORRELATION MATRIX SPLIT BY ENCOUNTER
(x <-   ggscatmat(df, columns = 1:11, color = "ENCOUNTER", alpha = 0.8) + 
    scale_color_manual(values = my_palettes(name="encounter", direction = "1"))+
    theme_minimal())

if(GRAPH_SAVE){
  ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("encounter_corr_abs.png"), units = c("in"), width = 14, height = 10 )
}
  x
  
  
```

##### CHART ACTION X SD

```{r, chart-action-sds}

  

df <- df_actions %>% select(MAKER_DESIGN, MAKER_DATA, 
                           MAKER_POLITIC, MAKER_ARGUE, MAKER_SELF, MAKER_ALIGN, MAKER_TRUST, 
                           CHART_TRUST, CHART_INTENT, CHART_LIKE, CHART_BEAUTY, 
                    PID, STIMULUS, BLOCK, STIMULUS_CATEGORY, 
                    CHART_ACTION) 
  
  ## CORRELATION MATRIX SPLIT BY CHART ACTION
(x <- ggscatmat(df, columns = 1:11, color = "CHART_ACTION", alpha = 0.2) + 
    scale_color_manual(values = my_palettes(name="actions", direction = "1"), name = "",  guide = guide_legend(reverse = TRUE)) +
    theme_minimal() )
if(GRAPH_SAVE){
ggsave(plot = x, path="figs/level_aggregated/pairplots", filename =paste0("chart_action_corr_sd.png"), units = c("in"), width = 14, height = 10  )
}
x


```

**Interesting patterns to explore further** - unfollow/block across all!






# !!!! TOP PRIORITY HYPOTHESIS TESTING  !!! 


 DONE - Beauty !== Trust, 
 2. Some individual visualizations have higher confidence, and some have lower (indexical richness), 
 3. Beauty + Trust = engagement, but Beauty + Untrust = less engagement
(SEE ENCOUNTER MODELLING IN CATEGORY LEVEL FILE )


## PREDICTING TRUST 

What predicts TRUST? Recent work in psychology suggests that beauty predicts trust. However, from our free response data, we think that some aesthetically pleasing images are interpreted as persuasive and thus less trustworthy.  On this basis, we predict that there will be a significant interaction between BEAUTY and INTENT


#### visualize 
```{r hypo-trust-beauty_intent-}

df <- df_graphs %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  # filter(STIMULUS != "B0-0") %>%
  select(PID, STIMULUS, STIMULUS_CATEGORY, BLOCK, ENCOUNTER, CHART_TRUST, CHART_BEAUTY, CHART_INTENT, MAKER_TRUST, MAKER_DATA, MAKER_ID) %>% 
  mutate(
    
    ## (only used if not filtering out B0-0)
    ## RECODE #recode b00 graph as category D [bc it fits in that category]
    # STIMULUS_CATEGORY = fct_recode(STIMULUS_CATEGORY, D="F") 
  ) %>% droplevels()


df %>% ggplot(aes(x=CHART_BEAUTY, y=CHART_TRUST, color = CHART_INTENT)) +
  geom_point() + 
  stat_smooth(method = "lm", formula = y ~ x, geom = "smooth") + 
  facet_wrap(~MAKER_ID)+
  labs(title = "CHART TRUST BY BEAUTY & INTENT") + 
  theme_minimal()
  
df %>% ggplot(aes(x=CHART_INTENT, y=CHART_TRUST, color = CHART_BEAUTY)) +
  geom_point() + 
  facet_wrap(~MAKER_ID)+
  stat_smooth(method = "lm", formula = y ~ x, geom = "smooth") + 
  labs(title = "CHART TRUST BY INTENT & BEAUTY")+ 
  theme_minimal()

df %>% ggplot(aes(x=MAKER_DATA, y=CHART_TRUST, color = CHART_BEAUTY)) +
  geom_point() + 
  facet_wrap(~MAKER_ID)+
  stat_smooth(method = "lm", formula = y ~ x, geom = "smooth") + 
  labs(title = "CHART TRUST BY INTENT & BEAUTY")+ 
  theme_minimal()

df %>% ggplot(aes(x=MAKER_ID, y=CHART_TRUST, color = CHART_BEAUTY)) +
  # geom_point() + 
  geom_boxplot() + geom_point(position=position_jitter(width = 0.2))+
  # stat_smooth(method = "lm", formula = y ~ x, geom = "smooth") + 
  labs(title = "CHART TRUST BY INTENT & BEAUTY")+ 
  theme_minimal()


```





#### MODEL

Is BEAUTY or INTENT a better predictor of TRUST?  Here we fit a series of linear mixed effects models, predicting `CHART_TRUST` by `CHART_BEAUTY` and `CHART_INTENT` 



##### SETUP DATA
```{r hypo-trust_beauty_intent-fit}

df <- df_graphs %>%
  ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
  # filter(STIMULUS != "B0-0") %>% 
  select(PID, STIMULUS,STIMULUS_CATEGORY, MAKER_ID, MAKER_TRUST, CHART_TRUST, CHART_BEAUTY, CHART_INTENT, MAKER_DATA) %>% 
  mutate(
    TRUST_Z = datawizard::standardise(CHART_TRUST),
    BEAUTY_Z = datawizard::standardise(CHART_BEAUTY),
    INTENT_Z = datawizard::standardise(CHART_INTENT),
    DATA_Z = datawizard::standardise(MAKER_DATA),
    r_MAKER_DATA = datawizard::reverse(MAKER_DATA), # reverse b/c 0 = professional, 100=layperson
    r_DATA_Z = datawizard::standardise(r_MAKER_DATA)
  ) %>% 
  droplevels()

################## BUILD MODELS #################

# # RANDOM INTERCEPT SUBJECT
# mm.rP <- lmer(CHART_TRUST ~ (1|PID), data = df)
# print("random effect only")
# summary(mm.rP)
```

##### TRUST ~ BEAUTY 
```{r}
################## TRUST ~ BEAUTY #################
f.B <-  "TRUST ~ BEAUTY + (1|PID)"
print("TRUSTS ~ BEAUTY + (1|PID)")
mm.B <- lmer(TRUST_Z ~ BEAUTY_Z + (1|PID), data = df)
car::Anova(mm.B, type=2)
summary(mm.B)
performance(mm.B)
## REPORT 
# report(mm.B)

## PLOT 
plot_model(mm.B, type = "eff", terms = "BEAUTY_Z") + 
  labs(subtitle = f.B) + theme_minimal()


## IN PAPER

```


##### TRUST ~ INTENT 
```{r}


################## TRUST ~ INTEN #################
f.I <-  "TRUST ~ INTENT + (1|PID)"
mm.I <- lmer(TRUST_Z ~ INTENT_Z + (1|PID), data = df)
car::Anova(mm.I, type=2)
summary(mm.I)
performance(mm.I)

## REPORT 
# report(mm.I)

## PLOT 
plot_model(mm.I, type = "pred", terms = "INTENT_Z") + 
  labs(subtitle = f.I) + theme_minimal()

## IN PAPER
tab_model(mm.I)

```



##### TRUST ~ DATA !!COMPETING!!
```{r}


################## TRUST ~ DATA #################
f.D <-  "TRUST ~ DATA + (1|PID)"
mm.D <- lmer(TRUST_Z ~ DATA_Z + (1|PID), data = df)
car::Anova(mm.D, type=2)
summary(mm.D)
performance(mm.D)

## REPORT 
# report(mm.I)

## PLOT 
plot_model(mm.D, type = "pred", terms = "DATA_Z") + 
  labs(subtitle = f.D) + theme_minimal()


```
##### TRUST ~ MAKER_ID
```{r}


################## TRUST ~ MAKER #################
f.M <-  "TRUST ~ MAKER + (1|PID)"
mm.M <- lmer(TRUST_Z ~ MAKER_ID + (1|PID), data = df)
car::Anova(mm.M, type=2)
summary(mm.M)
performance(mm.M)
## REPORT
# report(mm.M)

## PLOT
plot_model(mm.M, type = "pred", terms = "MAKER_ID") +
  labs(subtitle = f.M) + theme_minimal()

```



##### compare 
```{r}

compare_performance(mm.B, mm.I, mm.D, rank = TRUE)
anova(mm.B, mm.I, mm.D)

```



##### TRUST ~ BEAUTY X INTENT 
```{r}


## ADD IXN EFFECT 
################## TRUST ~ BEAUTY X INTENT  #################
f.BxI <-  "TRUST ~ BEAUTY X INTENT + (1|PID)"
print("TRUST ~ BEAUTY X INTENT + (1|PID)")
mm.BxI <- lmer(TRUST_Z ~ INTENT_Z * BEAUTY_Z +  (1|PID), data = df, REML=FALSE)
compare_performance(mm.BxI, mm.B, mm.I, rank = TRUE)
anova(mm.BxI, mm.B, mm.I)
# anova(mm.BxM, mm.BM)
print ("ADDING interaction BEAUTY * INTENT IMPROVES MODEL FIT  ")
car::Anova(mm.BxI, type=3)
summary(mm.BxI)


## REPORT 
# report(mm.BxI)

## PLOT 

## IN THE PAPER 
plot_model(mm.BxI, type = "int", terms = c("BEAUTY_Z", "INTENT_Z"), mdrt.values = "all") + 
  labs(subtitle = f.BxI) + theme_minimal()

plot_model(mm.BxI, type = "pred", terms = c("BEAUTY_Z", "INTENT_Z")) + 
  labs(subtitle = f.BxI) + theme_minimal()

# means <- estimate_means(mm.BxI, at=c("BEAUTY_Z", "INTENT_Z"))
# contrasts <- estimate_contrasts(mm.BxI, c( "INTENT_Z", "BEAUTY_Z"), method="pairwise")
# plot(means, contrasts)  #+  facet_wrap(~intent_Z) + labs(subtitle = f.BxI) + theme_minimal()


### IN THE PAPER 
tab_model(mm.BxI)

m <- mm.BxI
```







##### BEST TRUST ~ BEAUTY X INTENT + DATA *** BEST MODEL *** 
```{r}


################## TRUST ~ BEAUTY X INTENT  #################
f.BxID <-  "TRUST ~ BEAUTY X INTENT+DATA + (1|PID)"
print("TRUST ~ BEAUTY X INTENT + DATA + (1|PID)")
mm.BxID <- lmer(TRUST_Z ~ INTENT_Z * BEAUTY_Z + DATA_Z + (1|PID), data = df, REML=FALSE)
compare_performance(mm.BxI, mm.BxID, rank = TRUE)
anova(mm.BxI, mm.BxID)
# anova(mm.BxM, mm.BM)
car::Anova(mm.BxID, type=3)
summary(mm.BxID)


## REPORT 
# report(mm.BxI)

## PLOT 

## IN THE PAPER 
plot_model(mm.BxID, type = "int", terms = c("BEAUTY_Z", "INTENT_Z", "DATA_Z"), mdrt.values = "all") + 
  labs(subtitle = f.BxID) + theme_minimal()

plot_model(mm.BxID, type = "pred", terms = c("INTENT_Z", "BEAUTY_Z", "DATA_Z")) + 
  labs(subtitle = f.BxID) + theme_minimal()

## IN THE PAPER 
tab_model(mm.BxID)

# means <- estimate_means(mm.BxI, at=c("BEAUTY_Z", "INTENT_Z"))
# contrasts <- estimate_contrasts(mm.BxI, c( "INTENT_Z", "BEAUTY_Z"), method="pairwise")
# plot(means, contrasts)  #+  facet_wrap(~intent_Z) + labs(subtitle = f.BxI) + theme_minimal()

tab_model(mm.BxID)
anova(mm.B, mm.I, mm.D, mm.BxID)




p <- plot_model(mm.BxID, type = "pred", terms = c("INTENT_Z", "BEAUTY_Z", "DATA_Z")) + 
  labs(subtitle = f.BxID) + theme_minimal()



 ggsave(p, scale =1, filename = "figs/PAPER/mmBxID.svg", width = 14, height = 6, dpi = 320, limitsize = FALSE)
 t <- tab_model(mm.BxID)
# ggsave(t, scale =1, filename = "figs/PAPER/mmBxID_table.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)

# first save table to html file
tab_model(mm.BxID, file = "figs/PAPER/mmBxID_table.html")

# then take this html file and make .png file
webshot("figs/PAPER/mmBxID_table.html", "figs/PAPER/mmBxID_table.svg")
```
### not using 

##### TRUST ~ BEAUTY X MAKER_ID
```{r}

# 
# ## ADD IXN EFFECT 
# ################## TRUST ~ BEAUTY X MAKER_ID  #################
# f.BxM <-  "TRUST ~ BEAUTY X MAKER_ID + (1|PID)"
# print("TRUST ~ BEAUTY X MAKER_ID + (1|PID)")
# mm.BxM <- lmer(TRUST_Z ~ MAKER_ID * BEAUTY_Z +  (1|PID), data = df)
# compare_performance(mm.BxM, mm.BM, rank = TRUE)
# test_lrt(mm.BxM, mm.BM)
# # anova(mm.BxM, mm.BM)
# print ("ADDING interaction MAKER ID IMPROVES MODEL FIT ")
# car::Anova(mm.BxM, type=3)
# summary(mm.BxM)
# 
# 
# ## REPORT 
# report(mm.BxM)
# 
# ## PLOT 
# plot_model(mm.BxM, type = "int", terms = c("BEAUTY_Z", "MAKER_ID"), mdrt.values = "all") + 
#   labs(subtitle = f.BxM) + theme_minimal()
# 
# plot_model(mm.BXM, type = "pred", terms = c("BEAUTY_Z", "MAKER_ID")) + 
#   labs(subtitle = f.BM) + theme_minimal()
# 
# means <- estimate_means(mm.BM, at=c("BEAUTY_Z", "MAKER_ID"))
# contrasts <- estimate_contrasts(mm.BM, c( "MAKER_ID"),method="pairwise")
# plot(contrasts, means) + facet_wrap("MAKER_ID") + labs(subtitle = f.BxM) + theme_minimal()

```








##### TRUST ~ BEAUTY X MAKER_ID
```{r}

# 
# ## ADD IXN EFFECT 
# ################## TRUST ~ BEAUTY X MAKER_ID  #################
# f.BxM <-  "TRUST ~ BEAUTY X MAKER_ID + (1|PID)"
# print("TRUST ~ BEAUTY X MAKER_ID + (1|PID)")
# mm.BxM <- lmer(TRUST_Z ~ MAKER_ID * BEAUTY_Z +  (1|PID), data = df)
# compare_performance(mm.BxM, mm.BM, rank = TRUE)
# test_lrt(mm.BxM, mm.BM)
# # anova(mm.BxM, mm.BM)
# print ("ADDING interaction MAKER ID IMPROVES MODEL FIT ")
# car::Anova(mm.BxM, type=3)
# summary(mm.BxM)
# 
# 
# ## REPORT 
# report(mm.BxM)
# 
# ## PLOT 
# plot_model(mm.BxM, type = "int", terms = c("BEAUTY_Z", "MAKER_ID"), mdrt.values = "all") + 
#   labs(subtitle = f.BxM) + theme_minimal()
# 
# plot_model(mm.BXM, type = "pred", terms = c("BEAUTY_Z", "MAKER_ID")) + 
#   labs(subtitle = f.BM) + theme_minimal()
# 
# means <- estimate_means(mm.BM, at=c("BEAUTY_Z", "MAKER_ID"))
# contrasts <- estimate_contrasts(mm.BM, c( "MAKER_ID"),method="pairwise")
# plot(contrasts, means) + facet_wrap("MAKER_ID") + labs(subtitle = f.BxM) + theme_minimal()

```

##### TRUST ~ BEAUTY X MAKER_ID X INTENT
```{r}


# ## ADD IXN EFFECT 
# ################## TRUST ~ BEAUTY X MAKER_ID  #################
# f.BxMxI <-  "TRUST ~ BEAUTY X MAKER_ID X INTENT+ (1|PID)"
# print("TRUST ~ BEAUTY X MAKER_ID X INTENT + (1|PID)")
# mm.BxMxI <- lmer(TRUST_Z ~ MAKER_ID * BEAUTY_Z* INTENT_Z +  (1|PID), data = df)
# compare_performance(mm.BxMxI, mm.BxM, rank = TRUE)
# test_lrt(mm.BxMxI, mm.BxM)
# # anova(mm.BxM, mm.BM)
# car::Anova(mm.BxMxI, type=3)
# summary(mm.BxMxI)
# 
# 
# ## REPORT 
# report(mm.BxMxI)
# 
# ## PLOT 
# plot_model(mm.BxMxI, type = "int", mdrt.values = "all")
# 
# plot_model(mm.BxMxI, type = "pred", terms = c("BEAUTY_Z", "MAKER_ID", "INTENT_Z"))  
#   
# # 
# # means <- estimate_means(mm.BM, at=c("BEAUTY_Z", "MAKER_ID"))
# # contrasts <- estimate_contrasts(mm.BM, c( "MAKER_ID"),method="pairwise")
# # plot(contrasts, means) + facet_wrap("MAKER_ID") + labs(subtitle = f.BxM) + theme_minimal()
# 
# compare_performance(mm.BxI, mm.BxMxI, rank = TRUE)
# anova(mm.BxI, mm.BxMxI)
# 
# 
# 
# 
# 




```




```{r}
## INTENT MAIN EFFECT 
# SUBJECT INTERCEPT | FIXED BEAUTY 
print("TRUSTS ~ INTENT + (1|PID)")
mm.IrP <- lmer(CHART_TRUST ~ CHART_INTENT + (1|PID), data = df)
# :: TEST fixed factor 
compare_performance(mm.rP, mm.BrP, mm.IrP, rank = TRUE)
paste("AIC with INTENT is lower than BEAUTY model?", AIC(logLik(mm.BrP)) > AIC(logLik(mm.IrP)) )
anova(mm.BrP, mm.IrP, test = "Chi") #same as anova(m0, m1, test = "Chi")
print("A model with INTENT IS a better fit than model with BEAUTY")
car::Anova(mm.IrP, type=2)
print("BEAUTY IS a significant predictor in the model")
summary(mm.IrP)


## BEAUTY AND INTENT MAIN EFFECTS 
# SUBJECT INTERCEPT | BEAUTY + INTENT
print("TRUST ~ INTENT + BEAUTY + (1|PID)")
mm.IBrP <- lmer(CHART_TRUST ~ CHART_INTENT + CHART_BEAUTY + (1|PID), data = df)
# :: TEST fixed factor 
compare_performance(mm.rP, mm.BrP, mm.IrP, mm.IBrP, rank = TRUE)
##anova instead of LRT b/c models are not nested 
anova(mm.IrP,mm.IBrP, mm.BrP) #same as anova(m0, m1, test = "Chi")
test_lrt(mm.IrP, mm.IBrP)
test_lrt(mm.BrP, mm.IBrP)
paste("A model with a linear combination of BEAUTY and INTENT predicting TRUST is a significantly better fit than either fixed effect alone.")
car::Anova(mm.IBrP, type = 2)
summary(mm.IBrP)
print("CATEGORY is a significant predictor in this model, but BLOCK is not")


## BEAUTY INTENT INTERACTION
# SUBJECT INTERCEPT | INTENT * BEAUTY 
print("TRUST ~ INTENT * BEAUTY + (1|PID)")
mm.IBXrP <- lmer(CHART_TRUST ~ CHART_INTENT * CHART_BEAUTY + (1|PID), 
                data = df) 
               # control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               # optCtrl=list(maxfun=2e5)))
# :: TEST fixed factor 
compare_performance(mm.IBXrP, mm.IBrP, mm.IrP, mm.BrP, rank = TRUE)
##anova instead of LRT b/c models are not nested 
anova(mm.IBXrP, mm.IBrP)
test_lrt(mm.IBrP, mm.IBXrP, verbose = TRUE) #same as anova(m0, m1, test = "Chi")
paste("A model with an interaction is significantly better fit")
car::Anova(mm.IBXrP, type = 3)
print("In this model, both the main effects and interaction are significant")




#############VERSION WITH ZSCORED VARS 
## BEAUTY INTENT INTERACTION
# SUBJECT INTERCEPT | INTENT * BEAUTY 
print("TRUST ~ INTENT * BEAUTY + (1|PID)")
mm.ZIBXrP <- lmer(TRUST_Z ~ INTENT_Z * BEAUTY_Z + (1|PID), 
                data = df) 
               # control=glmerControl(optimizer="bobyqa", #would not converge under Nelder)Mead
               # optCtrl=list(maxfun=2e5)))
# :: TEST fixed factor 
compare_performance(mm.IBXrP, mm.ZIBXrP, rank = TRUE) ## should be the same
##anova instead of LRT b/c models are not nested 
car::Anova(mm.ZIBXrP, type = 3)
summary(mm.ZIBXrP)



## SET BEST 
m_best <- mm.ZIBXrP
f <- "(ZSCORED) TRUST ~ INTENT * BEAUTY"


############ PARTIAL CORRELATION SANITY CHECK 

# print("PARTIAL CORRELATION WITH PID AS RANDOM EFFECT")
# #CALCULATE partial correlations with PID as random effect
# ## (this isolates correlation pairwise factoring out other variables)
# c <- df %>% correlation(partial=TRUE,multilevel = TRUE)
# (s <- c %>% summary(redundant = FALSE ))


# ###### VIS WITH CORRELATION PACKAGE
# #SEE [correlation] PLOT
# g <- plot(s, show_data = "point",   show_text = "label",
#      stars=TRUE, show_legend=FALSE,
#      show_statistic = FALSE, show_ci = FALSE) + 
#      theme_minimal()+
#      labs(title = "All Stimuli | Correlation Matrix — SD Questions", 
#           subtitle="(partial correlation; pearson method; Holm p-value adjustment; participant as random effect)")
#      # text = list(fontface = "italic")
# g
# ggsave(g, scale =1, filename = "figs/level_aggregated/models/partial_correlation_mmIBXrP.png", width = 14, height = 6, dpi = 320, limitsize = FALSE)





```






#### model describe

```{r hypo-trust_beauty_intent}

############ DESCRIBE FINAL MODEL ###########
summary(m_best)
report(m_best)


######### PRINT COEFFICIENTS 
# print("COEFFICIENT ESTIMATES — LOG ODDS")
# tidy(m_best)
# print("COEFFICIENT ESTIMATES — ODDS RATIOS")
# tidy(m_best, exponentiate=TRUE)

``` 


#### check rescaling
```{r}
# 
# ## rescale all vars to be -1 to 0 to 1
# df <- df_graphs %>%
#   ## FILTER OUT B0-0 COMMON STIMULUS (so cells can be balanced)
#   # filter(STIMULUS != "B0-0") %>% 
#   select(PID, CHART_TRUST, CHART_BEAUTY, CHART_INTENT, MAKER_ID, STIMULUS_CATEGORY, MAKER_DATA) %>% 
#   mutate(
#     TRUST_Z = datawizard::standardise(CHART_TRUST),
#     BEAUTY_Z = datawizard::standardise(CHART_BEAUTY),
#     INTENT_Z = datawizard::standardise(CHART_INTENT),
#     r_MAKER_DATA = datawizard::reverse(MAKER_DATA), # reverse b/c 0 = professional, 100=layperson
#     r_DATA_Z = datawizard::standardise(r_MAKER_DATA),
#     
#     TRUST_S = datawizard::rescale(CHART_TRUST, to=c(-1,1)),
#     BEAUTY_S = datawizard::rescale(CHART_BEAUTY, to=c(-1,1)),
#     INTENT_S = datawizard::rescale(CHART_INTENT, to=c(-1,1)),
#     DATA_S = datawizard::rescale(MAKER_DATA, to=c(-1,1)),
#     r_DATA_S = datawizard::reverse(DATA_S), # reverse b/c 0 = professional, 100=layperson
#     
#     TRUST_SZ = datawizard::standardise(TRUST_S, to=c(-1,1))
#     
#   ) %>% 
#   droplevels()
# 
# 
# 
# gf_histogram(df, ~CHART_TRUST)
# gf_histogram(df, ~TRUST_S)
# gf_histogram(df, ~TRUST_Z)
# gf_histogram(df, ~TRUST_SZ)
#              



```

#### model vis
```{r hypo-category-encounter-modelvis}
# 
# ############ VISUALIZE MODEL COEFFICIENTS 
# #SJPLOT | MODEL | ODDS RATIO
# #library(sjPlot)
# plot_model(mm.ZIBXrP, type = "est",
#            vline.color = "red", 
#            show.intercept = TRUE, 
#            show.values = TRUE) + theme_minimal()  + 
#   labs(title = "Model Coefficients",
#        subtitle = "")
# 
# 
# 
# ############ VISUALIZE MODEL PREDICTIONS
# #SJPLOT | MODEL | PROBABILITIES
# plot_model(m_best, type = "int", mdrt.values = "meansd") + theme_minimal()
# 
# 
# plot_model(m_best, type="emm", 
#            terms = c("BEAUTY_Z"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for BEAUTY")
# 
# plot_model(m_best, type="emm", 
#            terms = c("INTENT_Z"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for INTENT")
# 
# plot_model(m_best, type="emm", 
#            terms = c("BEAUTY_Z","INTENT_Z"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for INTERACTION")
# 
# plot_model(m_best, type="emm", 
#            terms = c("INTENT_Z", "BEAUTY_Z"), ci.lvl = 0.95) + theme_minimal() + 
#   labs(title = "Estimated Marginal Means for INTERACTION")
# 
# 
# 
# ## CONTINUOUS INTERACTIONS 
# result <- estimate_expectation(m_best, data = "grid")
# plot(result) + theme_minimal()
# 
# result <- estimate_expectation(m_alt, data = "grid")
# plot(result) + theme_minimal()
# 
# 
# result <- estimate_prediction(m_best, data = "grid")
# plot(result) + theme_minimal()
# 
# 
# 
# 
# 
# ##EXAMPLES NOT WORKING EITHER
# # slopes <- estimate_slopes(m_best, trend = "INTENT_Z", by = "BEAUTY_Z")
# # plot(slopes)
# 
# 
# # model <- lm(mpg ~ hp * wt, data = mtcars)
# # slopes <- estimate_slopes(model, trend = "hp", by = "wt")
# # plot(slopes)
# 
# 
# 
# 
# ## TRY ADDING MAKER ID 
# 
# mm.beauty <- lmer(TRUST_Z ~ BEAUTY_Z + (1|PID), data = df)
# mm.intent <- lmer(TRUST_Z ~ INTENT_Z + (1|PID), data = df)
# mm.makerbeauty <- lmer(TRUST_Z ~ BEAUTY_Z*MAKER_ID + (1|PID), data = df)
# 
# 
# 
# plot_model(mm.beauty, type = "eff", terms = "BEAUTY_Z")
# plot_model(mm.intent, type = "eff", terms = "INTENT_Z")
# 
# plot_model(mm.makerbeauty, type = "int")
# 
# 
# 
#   plot_model(m_best, type = "int")
# 
# 
# plot_model(m_best, type = "int", mdrt.values = "all")
# 
# 
# mm.icat = update(m_best, .~. *MAKER_ID)
# compare_performance(m_best, mm.icat, mm.idata, rank = TRUE)
# car::Anova(mm.icat, type=3)
# plot_model(mm.icat, type = "int", mdrt.values = "meansd")
# 
# mm.idata = update(m_best, .~. *r_DATA_Z)
# compare_performance(m_best, mm.icat, mm.idata, rank = TRUE)
# car::Anova(mm.idata, type=3)
# plot_model(mm.idata, type = "int", mdrt.values = "meansd")
# 
# 
# 
# # plot_model(mm.ZIBXrP, type = "est",vline.color = "red", show.intercept = TRUE, show.values = TRUE) + theme_minimal()  + 
# #   labs(title = "Model Coefficients", subtitle = "")
# # plot_model(mm.cat, type = "est",vline.color = "red", show.intercept = TRUE, show.values = TRUE) + theme_minimal()  + 
# #   labs(title = "Model Coefficients", subtitle = "")
# # plot_model(mm.cat, type = "emm", terms=c("MAKER_ID" , "INTENT_Z","BEAUTY_Z"))
# 
# 
# 
# 


```











# EXPLORATORY QUESTIONS

-   When participants identify the maker as an INDIVIDUAL, the following
    variables show a different pattern than the other identifications:
    MAKER_DESIGN, MAKER_DATA, CHART INTENT
-   interesting bimodal distribution on CHART INTENT for most
    identifications, except individuals and organizations
    
    
    
    
    
    
### TOOL ID & DATA COMPETENCY    
    
```{r vis-tool-id-data, warning=FALSE}

df <- df_tools

## Does DATA COMPETENCY  depend on TOOL ID?
##RIDGEPLOT w/ MEAN 

answers <- levels(df$TOOL_ID)
left <- rep(ref_labels['MAKER_DATA','left'],  length(levels(df$MAKER_ID)))
right <- rep(ref_labels['MAKER_DATA','right'],  length(levels(df$MAKER_ID)))

df %>% 
    group_by(TOOL_ID) %>% 
    mutate(
      md=median(MAKER_DATA),
      m=mean(MAKER_DATA),
      count = n()
    ) %>% droplevels() %>% 
  ggplot(aes(y = TOOL_ID, x= MAKER_DATA, fill = TOOL_ID)) + 
  # scale_x_continuous(limits = c(0,100))+
  # geom_density_ridges(scale = 0.55,quantile_lines = TRUE, alpha = 0.75) +
  stat_halfeye(scale=0.8, density="bounded", point_interval = "median_qi", normalize="groups") +
  stat_pointinterval(side = "bottom", scale = 0.7, slab_linewidth = NA, point_interval = "median_qi") +
  ##MEDIAN
  stat_summary(fun=median, geom="text", colour="red",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(md, digits=0)))+
  stat_summary(fun=median, geom="point", shape=20, size=3, color="red", fill="red") +
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(m, digits=0)))+
  stat_summary(fun="mean", geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="tools", direction = "-1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
  guides(
      y = guide_axis_manual(labels = left, title = ""),
      y.sec = guide_axis_manual(labels = right)
    ) +
  geom_text(aes(label= paste0("n=",count) ,  y = TOOL_ID, x = 5), color = "black",size = 3, nudge_y = 0.3) +
  cowplot::draw_text(text = toupper(answers), x = 80, y= answers, size = 10, vjust=-2, hjust=0) +
  labs (title = "DATA COMPETENCY by TOOL ID", y = "", x = "MAKER DATA COMPETENCY", caption="(mean in blue) (median in red)") +
  theme_minimal() + easy_remove_legend()

```    



#### TODO PICKUP HERE model 




```{r}
# 
# df <- df_tools %>% 
#   mutate(
#     ## reverse order of MAKER_DATA, because scale ranged from 0=expert to 100=layperson
#     ## we want the reverse 
#     ## chose NOT to z-score data, bc we want the data in terms of the original scale 
#     r_MAKER_DATA = reverse_scale(MAKER_DATA),
#     STIMULUS_CATEGORY = fct_rev(STIMULUS_CATEGORY)
#   ) %>% filter(STIMULUS!="B0-0")
# 
# ## SET CONTRASTS
# # contrasts(df$MAKER_ID) <-car::contr.Treatment(levels(df$MAKER_ID)) # intercept first group mean; coeff dif from first
# 
# ## DEFINE MODEL
# lm5 <-lmer(r_MAKER_DATA ~ TOOL_ID + STIMULUS_CATEGORY*BLOCK +  (1|PID) , data=df)
# 
# # ## PRINT MODEL 
# # (m_eq <- extract_eq(m1, use_coef = TRUE, ital_vars = TRUE, coef_digits = 1, wrap = TRUE, intercept = "beta"))
# 
# ## DESCRIBE MODEL
# summary(lm5)
# anova(lm5)
# performance(m1)
# report(m1)
# 
# ## PLOT MODEL COEFFICIENTS
# coefs <- model_parameters(m1)
# plot_model(m1, type = "est",
#         # show.intercept = TRUE,
#         show.values = TRUE,
#         value.offset = .25,
#         show.p = TRUE
# ) + theme_minimal() + labs(caption=f)
# 
# 
# ## PLOT MODEL PREDICTIONS
# means <- estimate_means(m1, at = c("TOOL_ID"))
# 
# # sjPlot::plot_model(m1, type = "pred", terms = c("MAKER_ID")) +
# #     theme_minimal() + labs(caption=f)
# 
# # plot(means) + theme_minimal() + labs(caption=f) +
# # geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), 
# #           color="blue", position = position_nudge(x=0.25)) 
# 
# 
# ## PLOT MODEL PREDICTIONS with CONTRASTS
# 
# ## contrasts
# # black = estimated means and CI range; grey = CI range of the difference (as compared to the point estimate).  
# (contrasts <- estimate_contrasts(m1, contrast="TOOL_ID", method="pairwise"))
# plot(contrasts, means) + 
#     geom_text(aes(x=means$TOOL_ID, y=means$Mean, label=round(means$Mean,2)), color="blue", position = position_nudge(x=0.25)) + 
#   theme_minimal() + labs(caption =f, y="predicted MAKER DATA COMPETENCY \n (0=layperson, 100=expert)")
# 
# ##prediced data 
# plot_model(m1, type = "eff", terms = "TOOL_ID", show.p = TRUE,
#            show.values = TRUE, auto.label = TRUE)

```

```{r}
# <!-- ### JK DO QUANTILE REGRESSION AT THE MEDIAN  -->
# <!-- library(qrLMM) -->
# 
# 
# 
# <!-- ## tau is the quantile on which to run the model  -->
# <!-- m2 <-df %>% QRLMM(  -->
# <!--               y = r_MAKER_DATA,  -->
# <!--           r_MAKER_DATA ~ TOOL_ID,  -->
# <!--            random = ~ 1, -->
# <!--            group = PID, -->
# <!--            data=df, tau = 0.5) -->
# 
# 
# 
# <!-- summary(m2) -->
# <!-- plot_model(m1) -->

```





### MAKER ID & Maker DATA COMPETENCY

```{r vis-maker-id-data, warning=FALSE}

df <- df_graphs 

## Does MAKER_DATA  depend on MAKER ID?
##RIDGEPLOT w/ MEAN 

answers <- levels(df$MAKER_ID)
left <- rep(ref_labels['MAKER_DATA','left'],  length(levels(df$MAKER_ID)))
right <- rep(ref_labels['MAKER_DATA','right'],  length(levels(df$MAKER_ID)))

df %>% 
    group_by(MAKER_ID) %>% 
    mutate(
      md=median(MAKER_DATA),
      m=mean(MAKER_DATA),
      count = n()
    ) %>% 
  ggplot(aes(y = fct_rev(MAKER_ID), x= MAKER_DATA, fill = fct_rev(MAKER_ID))) + 
  scale_x_continuous(limits = c(0,100))+
  geom_density_ridges(scale = 0.55,quantile_lines = TRUE, alpha = 0.75) + 
  stat_pointinterval(side = "bottom", scale = 0.7, slab_linewidth = NA, point_interval = "mean_qi") +
  ##MEDIAN
  stat_summary(fun=median, geom="text", colour="red",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(md, digits=0)))+
  stat_summary(fun=median, geom="point", shape=20, size=3, color="red", fill="red") +
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(m, digits=0)))+
  stat_summary(fun="mean", geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="reds", direction = "-1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
  guides(
      y = guide_axis_manual(labels = left, title = ""),
      y.sec = guide_axis_manual(labels = right)
    ) +
  geom_text(aes(label= paste0("n=",count) ,  y = MAKER_ID, x = 100), color = "black",size = 3, nudge_y = 0.25) + 
  cowplot::draw_text(text = toupper(answers), x = 0, y= answers, size = 10, vjust=-2, hjust=0) + 
  labs (title = "DATA COMPETENCY by MAKER ID", y = "", x = "MAKER DATA COMPETENCY", caption="(mean in blue) (median in red)") +
  theme_minimal() + easy_remove_legend()

```

#### (YES) model

```{r model-maker-id-data}

### LINEAR MIXED EFFECTS MODEL ##################

df <- df_graphs 

## SET CONTRASTS
contrasts(df$MAKER_ID) <-car::contr.Treatment(levels(df$MAKER_ID)) # intercept first group mean; coeff dif from first

## DEFINE MODEL
f <- "MAKER_DATA ~ MAKER_ID + (1|PID) + (1|STIMULUS)"
m1 <-lmer(MAKER_DATA ~ MAKER_ID + (1|PID) + (1|STIMULUS), data=df)

## PRINT MODEL 
(m_eq <- extract_eq(m1, use_coef = TRUE, ital_vars = TRUE, coef_digits = 1, wrap = TRUE, intercept = "beta"))

## DESCRIBE MODEL
summary(m1)
anova(m1)
performance(m1)
report(m1)

## PLOT MODEL COEFFICIENTS
coefs <- model_parameters(m1)
plot_model(m1, type = "est",
        show.intercept = TRUE,
        show.values = TRUE,
        value.offset = .25,
        show.p = TRUE
) + theme_minimal() + labs(caption=f)


## PLOT MODEL PREDICTIONS
means <- estimate_means(m1, at = c("MAKER_ID"))

# sjPlot::plot_model(m1, type = "pred", terms = c("MAKER_ID")) +
#     theme_minimal() + labs(caption=f)

# plot(means) + theme_minimal() + labs(caption=f) +
# geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), 
#           color="blue", position = position_nudge(x=0.25)) 


## PLOT MODEL PREDICTIONS with CONTRASTS

## contrasts
# black = estimated means and CI range; grey = CI range of the difference (as compared to the point estimate).  
(contrasts <- estimate_contrasts(m1, contrast="MAKER_ID", method="pairwise"))
plot(contrasts, means) + 
    geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption = f)

```

### Maker ID & Maker DESIGN COMPETENCY

```{r}

df <- df_graphs

## Does MAKER_DESIGN  depend on MAKER ID?
##RIDGEPLOT w/ MEAN 

answers <- levels(df$MAKER_ID)
left <- rep(ref_labels['MAKER_DESIGN','left'],  length(levels(df$MAKER_ID)))
right <- rep(ref_labels['MAKER_DESIGN','right'],  length(levels(df$MAKER_ID)))

df %>% 
  group_by(MAKER_ID) %>% 
  mutate(
    count = n(), 
    m = mean(MAKER_DESIGN),
    md = median(MAKER_DESIGN)
    ) %>% 
  ggplot(aes(y = fct_rev(MAKER_ID), x= MAKER_DESIGN, fill = fct_rev(MAKER_ID))) + 
  scale_x_continuous(limits = c(0,100))+
  geom_density_ridges(scale = 0.55,quantile_lines = TRUE, alpha = 0.75) + 
  stat_pointinterval(side = "bottom", scale = 0.7, slab_linewidth = NA, point_interval = "mean_qi") +
  ##MEDIAN
  stat_summary(fun=median, geom="text", colour="red",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(md, digits=0)))+
  stat_summary(fun=median, geom="point", shape=20, size=3, color="red", fill="red") +
  ##MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(m, digits=0)))+
  stat_summary(fun="mean", geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="reds", direction = "-1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
  guides(
      y = guide_axis_manual(labels = left, title = ""),
      y.sec = guide_axis_manual(labels = right)
    ) +
  geom_text(aes(label= paste0("n=",count) ,  y = MAKER_ID, x = 100), color = "black",size = 3, nudge_y = 0.25) + 
  cowplot::draw_text(text = toupper(answers), x = 0, y= answers, size = 10, vjust=-2, hjust=0) + 
  labs (title = "DESIGN COMPETENCY by MAKER ID", y = "", x = "MAKER DESIGN COMPETENCY", caption="(mean in blue) (median in red)") +
  theme_minimal() + easy_remove_legend()

```

#### (YES) model

```{r model-maker-id-design}

### LINEAR MIXED EFFECTS MODEL ##################

df <- df_graphs 

## DEFINE MODEL
f <- "MAKER_DESIGN ~ MAKER_ID + (1|PID) + (1|STIMULUS)"
m1 <-lmer(MAKER_DESIGN ~ MAKER_ID + (1|PID) + (1|STIMULUS), data=df)

## PRINT MODEL 
(m_eq <- extract_eq(m1, use_coef = TRUE, ital_vars = TRUE, coef_digits = 1, wrap = TRUE, intercept = "beta"))

## DESCRIBE MODEL
summary(m1)
anova(m1)
performance(m1)
report(m1)

## PLOT MODEL COEFFICIENTS
coefs <- model_parameters(m1)
plot_model(m1, type = "est",
        show.intercept = TRUE,
        show.values = TRUE,
        show.p = TRUE
) + theme_minimal() + labs(caption=f)


## PLOT MODEL PREDICTIONS
means <- estimate_means(m1, at = c("MAKER_ID"))

# sjPlot::plot_model(m1, type = "pred", terms = c("MAKER_ID")) +
#     theme_minimal() + labs(caption=f)

# plot(means) + theme_minimal() + labs(caption=f) +
# geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), 
#           color="blue", position = position_nudge(x=0.25)) 


## PLOT MODEL PREDICTIONS with CONTRASTS

## contrasts
# black = estimated means and CI range; grey = CI range of the difference (as compared to the point estimate).  
(contrasts <- estimate_contrasts(m1, contrast="MAKER_ID", method="pairwise"))
plot(contrasts, means) + 
    geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption = f)

```

-   maker_design, chart_like, chart_beauty for BOOMER vs. others

-   maker_data for gen Z vs others

-   maker-data for FEMALE

-   maker data for design-basic, interesting pattern

-   look closer at chart beauty

-   interesting pattern across values on chart intent

— no difference at ALL in maker data - interesting! - chart beauty very
diff - chart intent intersting bimodal

### Maker ID & Maker POLITICS

\*\*Is there an association between MAKER ID and MAKER POLITICS? We
hypothesize that when the MAKER ID is identified as POLITICAL, the MAKER
POLITICS score will be more strongly associated with either ends of the
semantic differential scale (ie. left leaning or right leaning). We
expect this to not be the case with the other MAKER ID values.

To test this hypothesis, we will model MAKER_ID as a predictor of
MAKER_POLITICS_ABS (the absolute value of the collapsed maker politics
sd scale), where 0 = the midpoint of the original scale, and 50 = both
the 0 and 100 pts of the original scale

```{r, message=FALSE}

df <- df_graphs_abs

## Does MAKER POLITICS depend on MAKER ID?
##RIDGEPLOT w/ MEAN 
answers <- levels(df$MAKER_ID)
left <- rep(ref_labels_abs['MAKER_POLITIC','left'],  length(levels(df$MAKER_ID)))
right <- rep(ref_labels_abs['MAKER_POLITIC','right'],  length(levels(df$MAKER_ID)))

df %>% 
  group_by(MAKER_ID) %>% 
  mutate(
    count = n(),
    m = mean(MAKER_POLITIC),
    md = median(MAKER_POLITIC)
  ) %>% 
  ggplot(aes(y = fct_rev(MAKER_ID), x= MAKER_POLITIC, fill = fct_rev(MAKER_ID))) + 
  scale_x_continuous(limits = c(0,50))+
  geom_density_ridges(scale = 0.55,quantile_lines = TRUE, alpha = 0.75) + 
  stat_pointinterval(side = "bottom", scale = 0.7, slab_linewidth = NA, point_interval = "mean_qi") +
  ##MEDIAN
  stat_summary(fun=median, geom="text", colour="red",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(md, digits=0)))+
  stat_summary(fun=median, geom="point", shape=20, size=3, color="red", fill="red") +
  ##MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(m, digits=0)))+
  stat_summary(fun="mean", geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="reds", direction = "-1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
  guides(
      y = guide_axis_manual(labels = left, title = ""),
      y.sec = guide_axis_manual(labels = right)
    ) +
  geom_text(aes(label= paste0("n=",count) ,  y = MAKER_ID, x = 50), color = "black",size = 3, nudge_y = 0.25) + 
  cowplot::draw_text(text = toupper(answers), x = 0, y= answers, size = 10, vjust=-2, hjust=0) + 
  labs (title = "POLITICS (absolute value) by MAKER ID", y = "", x = "MAKER POLITICS", caption="(mean in blue) (median in red)") +
  theme_minimal() + easy_remove_legend()

```

Once the MAKER_POLITICS score has been collapsed to the SD scale, we see
that our hypothesis is likely false, as the mean (absolute value)
maker_politics scores are nearly the same for individual, organization
and politics, with only news, education and business being slighly more
neutral.

#### (NO) model

```{r model-maker-id-politics}

### LINEAR MIXED EFFECTS MODEL ##################

df <- df_graphs_abs

## DEFINE MODEL
f <- "MAKER_POLITIC ~ MAKER_ID + (1|PID) + (1|STIMULUS)"
m1 <-lmer(MAKER_POLITIC ~ MAKER_ID + (1|PID) + (1|STIMULUS), data=df)

## PRINT MODEL 
(m_eq <- extract_eq(m1, use_coef = TRUE, ital_vars = TRUE, coef_digits = 1, wrap = TRUE, intercept = "beta"))

## DESCRIBE MODEL
summary(m1)
anova(m1)
performance(m1)
report(m1)

## PLOT MODEL COEFFICIENTS
coefs <- model_parameters(m1)
plot_model(m1, type = "est",
        show.intercept = TRUE,
        show.values = TRUE,
        show.p = TRUE
) + theme_minimal() + labs(caption=f)


## PLOT MODEL PREDICTIONS
means <- estimate_means(m1, at = c("MAKER_ID"))

# sjPlot::plot_model(m1, type = "pred", terms = c("MAKER_ID")) +
#     theme_minimal() + labs(caption=f)

# plot(means) + theme_minimal() + labs(caption=f) +
# geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), 
#           color="blue", position = position_nudge(x=0.25)) 


## PLOT MODEL PREDICTIONS with CONTRASTS

## contrasts
# black = estimated means and CI range; grey = CI range of the difference (as compared to the point estimate).  
(contrasts <- estimate_contrasts(m1, contrast="MAKER_ID", method="pairwise"))
plot(contrasts, means) + 
    geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption = f)

```

The results of the model confirm our suspicion that our hypothesis is
not supported by the data. MAKER_ID is not a strong predictor of
MAKER_POLITICS (absolute value). Post-hoc contrasts demonstrate that the
mean values of some levels are significantly different (e.g individual
v. education, organization v. education, education v. political) however
the overall model does not indicate a good fit.

### Maker ID & Maker TRUST

\*\*Do people indicate higher TRUST in artifacts they attribute to
EDUCATION type makers?

```{r}

df <- df_graphs

## Does MAKER_TRUST  depend on MAKER ID?
##RIDGEPLOT w/ MEAN 

answers <- levels(df$MAKER_ID)
left <- rep(ref_labels['MAKER_TRUST','left'],  length(levels(df$MAKER_ID)))
right <- rep(ref_labels['MAKER_TRUST','right'],  length(levels(df$MAKER_ID)))

df %>% 
  group_by(MAKER_ID) %>% 
  mutate(
    count = n(), 
    m=mean(MAKER_TRUST),
    md=median(MAKER_TRUST)
    ) %>% 
  ggplot(aes(y = fct_rev(MAKER_ID), x= MAKER_TRUST, fill = fct_rev(MAKER_ID))) + 
  scale_x_continuous(limits = c(0,100))+
  geom_density_ridges(scale = 0.55,quantile_lines = TRUE, alpha = 0.75) + 
  stat_pointinterval(side = "bottom", scale = 0.7, slab_linewidth = NA, point_interval = "mean_qi") +
  ##MEDIAN
  stat_summary(fun=median, geom="text", colour="red",  fontface = "bold", size = 2.5,
               vjust=+2, hjust = 0, aes( label=round(md, digits=0)))+
  stat_summary(fun=median, geom="point", shape=20, size=3, color="red", fill="red") +
  ## MEAN
  stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", size = 2.5, 
               vjust=+2, hjust = 0, aes( label=round(m, digits=0)))+
  stat_summary(fun="mean", geom="point", shape=20, size=3, color="blue", fill="blue") +
  scale_fill_manual(values = my_palettes(name="reds", direction = "-1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
  guides(
      y = guide_axis_manual(labels = left, title = ""),
      y.sec = guide_axis_manual(labels = right)
    ) +
  geom_text(aes(label= paste0("n=",count) ,  y = MAKER_ID, x = 100), color = "black",size = 3, nudge_y = 0.25) + 
  cowplot::draw_text(text = toupper(answers), x = 0, y= answers, size = 10, vjust=-2, hjust=0) + 
  labs (title = "MAKER TRUST  by MAKER ID", y = "", x = "MAKER TRUST", caption="(mean in blue) (median in red)") +
  theme_minimal() + easy_remove_legend()

```

#### (YES) model

```{r model-maker-id-trust}

### LINEAR MIXED EFFECTS MODEL ##################

df <- df_graphs 

## DEFINE MODEL
f <- "MAKER_TRUST ~ MAKER_ID + (1|PID) + (1|STIMULUS)"
m1 <-lmer(MAKER_TRUST ~ MAKER_ID + (1|PID) + (1|STIMULUS), data=df)

## PRINT MODEL 
(m_eq <- extract_eq(m1, use_coef = TRUE, ital_vars = TRUE, coef_digits = 1, wrap = TRUE, intercept = "beta"))

## DESCRIBE MODEL
summary(m1)
anova(m1)
performance(m1)
report(m1)

## PLOT MODEL COEFFICIENTS
coefs <- model_parameters(m1)
plot_model(m1, type = "est",
        show.intercept = TRUE,
        show.values = TRUE,
        show.p = TRUE
) + theme_minimal() + labs(caption=f)


## PLOT MODEL PREDICTIONS
means <- estimate_means(m1, at = c("MAKER_ID"))

# sjPlot::plot_model(m1, type = "pred", terms = c("MAKER_ID")) +
#     theme_minimal() + labs(caption=f)

# plot(means) + theme_minimal() + labs(caption=f) +
# geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), 
#           color="blue", position = position_nudge(x=0.25)) 


## PLOT MODEL PREDICTIONS with CONTRASTS

## contrasts
# black = estimated means and CI range; grey = CI range of the difference (as compared to the point estimate).  
(contrasts <- estimate_contrasts(m1, contrast="MAKER_ID", method="pairwise"))
plot(contrasts, means) + 
    geom_text(aes(x=means$MAKER_ID, y=means$Mean, label=round(means$Mean,1)), color="blue", position = position_nudge(x=0.25)) + 
  theme_minimal() + labs(caption = f)

```

# STASH

wip code stash


## sparkline table examples
```{r}

# library(tinytable)
# 
# 
# ################################# CARS
# plot_data <- list(mtcars$mpg, mtcars$hp, mtcars$qsec)
# 
# dat <- data.frame(
#   Variables = c("mpg","hp","qsec"),
#   Histogram="",
#   Density="",
#   Bar=""
# )
# 
# tt(dat) %>% 
#   plot_tt(j=2, fun = "histogram", data = plot_data) %>% 
#   plot_tt(j=3, fun = "density", data = plot_data) %>% 
#   plot_tt(j=4, fun = "bar", data = list(2,3,6))
#   # plot_tt(j=5, fun = "line", data = plot_data) %>% 
#   # style_tt(j = 2:3, align = "c")
# 
# #################################
# 
# 
# 
# ###################### GGPLOT CUSTOM GRAPH IN TABLE
# 
# 
# penguins<-read.csv( "https://vincentarelbundock.github.io/Rdatasets/csv/palmerpenguins/penguins.csv", na.strings= "") |> na.omit() 
# #splitdatabyspecies 
# dat<-split(penguins,penguins$species) 
# body<-lapply(dat,\(x)x$body_mass_g) 
# flip<-lapply(dat,\(x)x$flipper_length_mm) 
# #createnearlyemptytable 
# tab<-data.frame( "Species" =names(dat), "Body Mass"= "", "FlipperLength" ="", "Body vs. Flipper"= "", check.names= FALSE ) 
# 
# #customggplot2functiontocreateinlineplot 
# f<-function(d,...){ 
#   ggplot(d,aes(x= flipper_length_mm,y=body_mass_g, color= sex)) + 
#     geom_point(size= .2) + scale_x_continuous(expand=c(0,0))+  
#     scale_y_continuous(expand=c(0,0)) + scale_color_manual(values=  c("#E69F00", "#56B4E9")) + theme_void() + theme(legend.position="none") 
# } 
# 
# #`tinytable` calls 
# 
# tt(tab) |> 
#   plot_tt(j=2,fun= "histogram",data = body, height= 2)|> 
#   plot_tt(j=3,fun= "density", data= flip,height= 2) |> 
#   plot_tt(j=4,fun= f, data= dat, height= 2)|> 
#   style_tt(j= 2:4, align="c")

#################################
```

## half boxplot raincloud mean

```{r}
# ## HALF BOXPLOT + DOTPLOT + MEAN
# ##############################
# H <-  df %>% 
#   group_by(MAKER_AGE) %>% 
#   mutate(count = n(), m = mean(MAKER_CONF)) %>% 
#   ggplot(aes(y = MAKER_CONF, x = fct_rev(MAKER_AGE), color = fct_rev(MAKER_AGE))) + 
#     geom_half_boxplot(side="r", alpha = 0.5, aes(fill=fct_rev(MAKER_AGE))) + 
#     stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", 
#                vjust=-0.75, hjust = 1, aes( label=round(..y.., digits=0)))+
#     scale_color_manual(values = my_palettes(name="lightblues", direction = "-1"), 
#                        guide = guide_legend(reverse = TRUE)) + 
#     scale_fill_manual(values = my_palettes(name="lightblues", direction = "-1"), 
#                       guide = guide_legend(reverse = TRUE)) + 
#     stat_dotsinterval(side = "bottom", scale = 0.7, slab_linewidth = NA, 
#                         aes(fill = fct_rev(MAKER_AGE)) , color="black",  point_interval = "mean_qi")  +
#     stat_summary(fun="mean", geom="point", shape=20, size=5, color="blue", fill="blue") +
#     geom_text(aes(label= paste0("n=",count) ,  y = 5), color = "black",
#             size = 3, nudge_x=0.35) + 
#   labs(y="Maker Age Confidence", x="") + 
#   theme_minimal() + 
#   easy_remove_legend()+
#   coord_flip() 
# ##############################
#   

```

## wip confidence modelling

```{r}
# 
# ## [test-frame] Are the confidence scores significantly different for different questions?
# ## [model-frame] Does QUESTION predict CONFIDENCE, accounting for random variance in SUBJECT and STIMULUS?
# 
# 
# ## MIXED model with random variance only at subject (not stimulus)
# mm1 <- lmer( CONFIDENCE ~ QUESTION + (1|PID), data = df)
# # summary(mm1)
# # plot(check_model(mm1))
# # pm <- model_parameters(mm1)
# # plot(pm, show_labels = TRUE, show_intercept = TRUE) + labs(title = "CONFIDENCE ~ QUESTION + (1|PID)")
# # performance(mm1)
# # report(mm1)
# 
# 
# ## MIXED model with random variance only at subject AND stimulus
# mm2 <- lmer( CONFIDENCE ~ QUESTION + (1|PID) + (1|STIMULUS), data = df)
# # summary(mm2)
# # plot(check_model(mm2))
# # pm <- model_parameters(mm2)
# # plot_model(mm2)
# # plot(pm, show_labels = TRUE, show_intercept = TRUE) + labs(title = "CONFIDENCE ~ QUESTION + (1|PID) + (1|STIMULUS)")
# # performance(mm2)
# # report(mm2)
# 
# 
# ## MIXED model with random slope for question by person and random intercept by stimulus
# mm3 <- lmer( CONFIDENCE ~ QUESTION +  (1 + QUESTION | PID) + (1|STIMULUS), data = df)
# # summary(mm3)
# # plot(check_model(mm3))
# # pm <- model_parameters(mm3)
# # plot(pm, show_labels = TRUE, show_intercept = TRUE) + labs(title = "CONFIDENCE ~ QUESTION +   (1 + QUESTION | PID) + (1|STIMULUS)")
# # performance(mm3)
# # report(mm3)
# 
# 
# ## MIXED model with STIMULUS as FIXED effect and random intercept by person
# mm4 <- lmer( CONFIDENCE ~ QUESTION + STIMULUS +  (1 | PID), data = df)
# # summary(mm4)
# # plot(check_model(mm4))
# # pm <- model_parameters(mm4)
# # plot(pm, show_labels = TRUE, show_intercept = FALSE) + labs(title = "CONFIDENCE ~ QUESTION + STIMULUS +  (1 | PID)")
# # performance(mm4)
# # report(mm4)
# 
# ## MIXED model with STIMULUS * QUESTION interaction and random intercept by person
# mm5 <- lmer( CONFIDENCE ~ QUESTION * STIMULUS +  (1 | PID), data = df)
# # summary(mm5)
# # plot(check_model(mm5))
# # pm <- model_parameters(mm5)
# # plot(pm, show_labels = TRUE, show_intercept = FALSE) + labs(title = "CONFIDENCE ~ QUESTION * STIMULUS +  (1 | PID)")
# # performance(mm5)
# # report(mm5)
# 
# 
# ## MIXED model with STIMULUS * QUESTION interaction and random intercept by person
# mmx <- lmer( CONFIDENCE ~ STIMULUS  +  (1 | PID) + (1 | QUESTION), data = df)
# # summary(mmx)
# # plot(check_model(mmx))
# # pm <- model_parameters(mmx)
# # plot(pm, show_labels = TRUE, show_intercept = FALSE) + labs(title = "CONFIDENCE ~ STIMULUS  +  (1 | PID) + (1 | QUESTION)")
# # performance(mmx)
# # report(mmx)
# 
# 
# ### COMPARE MODELS
# # compare_parameters(mm1,mm2,mm3, mm4, mm5, mmx)
# compare_performance(mm1,mm2,mm3, mm4, mm5, mmx, rank = TRUE )
# ## model 3 is the best fit, and is appropriate to the design of the study
# summary(mm3)
# report(mm3)
# # plot_model(mm3, terms = c("QUESTION", "STIMULUS"), type = "diag")
# 
# # # ## repeated measures aov
# # print("Repeated Measures ANOVA")
# # ex1 <- aov(CONFIDENCE~QUESTION+Error(PID), data=df)
# # summary(ex1)
# # report(ex1)
# 




```

## correlation plot code

```{r}
# ## SHADED CIRCLES
# corrplot(m, method = 'circle', type = 'lower', 
#          order = 'AOE', diag = FALSE,
#          insig='blank',
#          tl.col = "black")
# 
# 
# ## SHADED NUMBERS
# corrplot(m,  order = 'AOE', method = "number", 
#          diag = FALSE, type = "lower",
#          insig='blank',
#          # insig = 'label_sig', sig.level = c(0.001, 0.01, 0.05),
#          addCoef.col = '#595D60',
#          tl.pos = "ld", tl.col = "#595D60")
#          
# 
# ## SHADED SQUARED + COEFFS
# corrplot(m,  order = 'AOE', method = "circle", 
#          diag = FALSE, type = "lower",
#          insig='blank', sig.level = 0.05,
#          # insig = 'label_sig', sig.level = c(0.001, 0.01, 0.05),
#          addCoef.col = '#595D60',
#          tl.pos = "ld", tl.col = "#595D60")
#          

```

## flip some sds

```{r}



############## SETUP FOR FLIPPING SCALES ON SOME QUESTIONS TO MAKE THEM MORE READABLE
ref_sd_reordered <- c("MAKER_DATA","MAKER_DESIGN", 
                    "CHART_BEAUTY", "CHART_LIKE", 
                    "MAKER_POLITIC","MAKER_ARGUE", "MAKER_SELF", "CHART_INTENT",
                    "MAKER_ALIGN","MAKER_TRUST",
                    "CHART_TRUST")

left_reordered <- c("layperson","layperson", 
                    "NOT at all","NOT at all",
                    "left-leaning",
                    "diplomatic",
                    "altruistic",
                    "inform",    
                    "DOES share", 
                    "untrustworthy",
                    "untrustworthy")
right_reordered <- c("professional","professional",
                     "very much", "very much",          
                     "right-leaning",
                     "confrontational",
                     "selfish", 
                     "persuade",
                     "does NOT share", 
                     "trustworthy",
                     "trusthworthy")

ref_labels_reordered <- as.data.frame(cbind(left_reordered,right_reordered))
rownames(ref_labels_reordered) <- ref_sd_questions




```

## correlation matrix

```{r}
## GGALLY correlation heatmap
# ggcorr(df,
#        label = TRUE,  geom = "tile",
#        nbreaks = 5, layout.exp = 2,   
#        # label_round = 2,
#        angle = -0, hjust = 0.8, vjust = 1, size = 2.5,
#        low = "#D88585",mid = "white", high= "#6DA0D6") +
#        easy_remove_legend() + 
#   labs(title = "Correlation between SD measures", subtitle = ("pairwise; Pearson correlations"))
```

## ridgeplot with interval and mean

```{r}

# ## Does MAKER_TRUST  depend on MAKER ID?
# ##RIDGEPLOT w/ MEAN 
# answers <- levels(df$MAKER_ID)
# left <- rep(ref_labels['MAKER_TRUST','left'],  length(levels(df$MAKER_ID)))
# right <- rep(ref_labels['MAKER_TRUST','right'],  length(levels(df$MAKER_ID)))
# df %>% ggplot(aes(y = fct_rev(MAKER_ID), x= MAKER_TRUST, fill = fct_rev(MAKER_ID))) + 
#   geom_density_ridges(scale = 0.55,quantile_lines = TRUE, alpha = 0.75) + 
#   stat_dotsinterval(side = "bottom", scale = 0.7, slab_linewidth = NA, point_interval = "mean_qi") +
#   stat_summary(fun=mean, geom="text", colour="blue",  fontface = "bold", 
#                vjust=+2, hjust = 0, aes( label=round(..x.., digits=0)))+
#     stat_summary(fun="mean", geom="point", shape=20, size=5, color="blue", fill="blue") +
#   scale_fill_manual(values = my_palettes(name="reds", direction = "-1"), name = "",  guide = guide_legend(reverse = TRUE)) +   
#     guides(
#       y = guide_axis_manual(labels = left, title = ""),
#       y.sec = guide_axis_manual(labels = right)
#     ) +
#    cowplot::draw_text(text = toupper(answers), x = 10, y= answers,size = 10, vjust=-2) + 
#   labs (title = "MAKER TRUST by MAKER ID", y = "", x = "MAKER TRUST", caption="(mean in blue)") +
#   theme_minimal() + easy_remove_legend()


```

## lessR donuts

```{r b2_donuts}
##good for seeing the color schemes 
# #### DEFINE SET 
# stimulus  = "B2-1"
# df <- df_graphs %>% filter(STIMULUS == stimulus)
# 
# #### GENERATE GRAPHS
# 
#   #MAKER_ID-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "reds",
#          main = paste0(stimulus, " MAKER ID")) + theme_minimal()
# 
# 
# #MAKER_GENDER-DONUT
# PieChart(MAKER_GENDER, data = df,
#        fill = "blues",
#        main = paste0(stimulus, " MAKER GENDER")) + theme_minimal()
# 
# 
# #MAKER_AGE-DONUT
# PieChart(MAKER_AGE, data = df,
#        fill = "olives",
#        main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
# 
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "rusts",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "olives",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "greens",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "emeralds",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "turquoises",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "aquas",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-MAKER_ID
#   PieChart(MAKER_ID, data = df,
#          fill = "purples",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "magentas",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "violets",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
#   
#   #MAKER_AGE-DONUT
#   PieChart(MAKER_ID, data = df,
#          fill = "grays",
#          main = paste0(stimulus, " MAKER AGE")) + theme_minimal()
# "reds"	h	0
# "rusts"	h	30
# "browns"	h	60
# "olives"	h	90
# "greens"	h	120
# "emeralds"	h	150
# "turquoises"	h	180
# "aquas"	h	210
# "blues"	h	240
# "purples"	h	270
# "violets"	h	300
# "magentas"	h	330
# "grays"

```

## ggplot donuts

```{r}
#   df <- df_graphs %>% filter(STIMULUS== s)
# #### CATEGORICAL DONUT PLOTS
#   #subset data cols 
#   cols <- df %>% select( all_of(ref_cat_questions))
#   
#   ggplot( df, aes( x = STIMULUS, fill = MAKER_ID)) +
#   geom_bar( position = "stack", width=1) +
#   coord_radial(theta = "y", start = 0, inner.radius = 0.5, expand=FALSE) +
#   scale_fill_manual(values = my_palettes(name="reds", direction = "1"), name = "",  guide = guide_legend(reverse = FALSE)) +   
#   labs( title = paste0(s, " MAKER ID")) +
#   theme_minimal()
#   
#   
```

## Alluvial Plots

```{r}
## EXAMPLE ALLUVIAL PLOT USING GGALUVIAL  (instead of GGSANKEY)
# https://corybrunson.github.io/ggalluvial/articles/ggalluvial.html

# #FILTER FOR BLOCK 2 STIM AND RESHAPE FOR SANKEY
# ds <- df_graphs %>% 
#   filter(str_detect(STIMULUS, "B2")) %>% 
#   select(STIMULUS, MAKER_ID, PID) %>% 
#   mutate(
#     MAKER_ID = fct_relevel(MAKER_ID, 
#               c("business","education","individual", "news","organization", "political" ))
#   )
# 
# ds %>% 
#   ggplot(aes( x = STIMULUS,
#               stratum = MAKER_ID,
#               label = MAKER_ID,
#               alluvium = PID)) +
#       stat_alluvium(aes(fill = MAKER_ID),
#                     width = 0,
#                     alpha = 1,
#                     geom = "flow")+
#       geom_stratum(width = 0.2, aes(fill= MAKER_ID))+
#       # geom_text(stat = "stratum", size = 5, angle = 90)+
#       scale_fill_viridis(discrete=TRUE, option="viridis", drop = FALSE,
#                      alpha = 1) +
#       theme_minimal()
```

## AD and KS Tests Comparing of Distributions 

Are the confidence distributions for each question _different_? Note that central tendency is not a good measure here, because we care a great deal about the shape of the distribution. KS Tests can be used to compare 2 empirical distributions (and AD tests more than 2) to against the null hypothesis that they were drawn from the same population. HOWEVER BOTH tests assume the variables are independent (i.e. not repeated measures or from the same sample) so it is not appropriate to use them to compare distributions of our survey vars 
```{r}

# df <- df_full

## PAIRWISE KS-TESTS 
# ks.test(df$MAKER_CONF, df$AGE_CONF,
#         alternative="two.sided",
#         simulate.p.value = TRUE )
# 
# ks.test(df$MAKER_CONF, df$GENDER_CONF,
#         alternative="two.sided",
#         simulate.p.value = TRUE )
# 
# ks.test(df$MAKER_CONF, df$TOOL_CONF,
#         alternative="two.sided",
#         simulate.p.value = TRUE )
# 
# 
# ks.test(df$GENDER_CONF, df$AGE_CONF,
#         alternative="two.sided",
#         simulate.p.value = TRUE )
# 
# ks.test(df$GENDER_CONF, df$TOOL_CONF,
#         alternative="two.sided",
#         simulate.p.value = TRUE )
# 
# ks.test(df$AGE_CONF, df$TOOL_CONF,
#         alternative="two.sided",
#         simulate.p.value = TRUE )



# 
# 
# ## kSamples
# # library(kSamples)
# ad.test( df$MAKER_CONF, df$AGE_CONF, df$GENDER_CONF, df$TOOL_CONF,
#          method = "asymptotic")
```

## Friedman rank Sum test comparing distirbutions unreplicated blocked data 
```{r}
# 
# # setup dataframe 
# df <- df_graphs 
# 
# ## COMPARE POLITICS, ARGUE, SELFISH, ALIGNMENT 
# 
# 
# ## CHART LIKE AND CHART BEAUTY  
# df <- df_sd_questions_long %>% select(PID, QUESTION, STIMULUS, value) %>% 
#   filter( QUESTION %in% c("CHART_LIKE", "CHART_BEAUTY")) %>% 
#   group_by(QUESTION, PID) %>%   ## HAVE TO COLLAPSE ACROSS STIMULI TO RUN FREIDMAN TEST 
#   summarise( 
#     m_value=round(mean(value),0) #calc mean for showing in plots 
# ) %>% droplevels()
# 
# df <- as.data.frame(df)
# friedman.test( data = df, m_value ~ QUESTION | PID)
# ## EFFECT SIZE 
# friedman_effsize( data = df, m_value ~ QUESTION | PID)
# 
# 
# ## CHART TRUST AND MAKER TRUST
# df <- df_sd_questions_long %>% select(PID, QUESTION, STIMULUS, value) %>% 
#   filter( QUESTION %in% c("CHART_TRUST", "MAKER_TRUST")) %>% 
#   group_by(QUESTION, PID) %>%   ## HAVE TO COLLAPSE ACROSS STIMULI TO RUN FREIDMAN TEST 
#   summarise( 
#     m_value=round(mean(value),0) #calc mean for showing in plots 
# ) %>% droplevels()
# 
# df <- as.data.frame(df)
# friedman.test( data = df, m_value ~ QUESTION | PID)
# ## EFFECT SIZE 
# friedman_effsize( data = df, m_value ~ QUESTION | PID)
# 
# 
# 
# ## COMPARE POLITICS, ARGUE, SELFISH, ALIGNMENT 
# df <- df_sd_questions_long %>% select(PID, QUESTION, STIMULUS, value) %>% 
#   filter( QUESTION %in% c("MAKER_POLITIC", "MAKER_ARGUE", "MAKER_SELFISH", "MAKER_ALIGN")) %>% 
#   group_by(QUESTION, PID) %>%   ## HAVE TO COLLAPSE ACROSS STIMULI TO RUN FREIDMAN TEST 
#   summarise( 
#     m_value=round(mean(value),0) #calc mean for showing in plots 
# ) %>% droplevels()
# 
# df <- as.data.frame(df)
# friedman.test( data = df, m_value ~ QUESTION | PID)
# ## EFFECT SIZE 
# friedman_effsize( data = df, m_value ~ QUESTION | PID)
# 
# 
# 
# 
# #### SOMETHING WE EXPECT TO BE VERY DIFFERENT 
# ## DESIGN COMPETENCY AND POLITICS 
# df <- df_sd_questions_long %>% select(PID, QUESTION, STIMULUS, value) %>% 
#   filter( QUESTION %in% c("MAKER_POLITIC", "MAKER_DESIGN")) %>% 
#   group_by(QUESTION, PID) %>%   ## HAVE TO COLLAPSE ACROSS STIMULI TO RUN FREIDMAN TEST 
#   summarise( 
#     m_value=round(mean(value),0) #calc mean for showing in plots 
# ) %>% droplevels()
# 
# df <- as.data.frame(df)
# friedman_test( data = df, m_value ~ QUESTION | PID)
# ## EFFECT SIZE 
# friedman_effsize( data = df, m_value ~ QUESTION | PID)
# 
# gf_histogram(df, ~m_value) + facet_wrap(~QUESTION)

```


# RESOURCES

-   custom color palettes:
    <https://www.r-bloggers.com/2022/06/custom-colour-palettes-for-ggplot2/>
-   lessR donuts <https://r-charts.com/part-whole/donut-chart/>
-   GGSANKEY <https://github.com/davidsjoberg/ggsankey>
-   GGALLUVIAL
    <https://corybrunson.github.io/ggalluvial/articles/ggalluvial.html>
-   variable standardization [variable (vs) participant]
    :<https://cran.r-project.org/web/packages/datawizard/vignettes/standardize_data.html>
-   contrasts:
-   UCLA:<https://stats.oarc.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables>
-   <https://phillipalday.com/stats/lazy-contrasts.html>
-   level naming with contrasts :<https://rpubs.com/bbolker/5335>
-   ggdist slab normaliztion https://mjskay.github.io/ggdist/articles/thickness.html
- visualizing regression models visreg https://pbreheny.github.io/visreg/index.html
